"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[3420],{3684:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"guides/error-handling","title":"Error Handling","description":"Comprehensive guide to handling errors in flutterinapppurchase for robust and user-friendly applications.","source":"@site/versioned_docs/version-6.3/guides/error-handling.md","sourceDirName":"guides","slug":"/guides/error-handling","permalink":"/docs/6.3/guides/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/versioned_docs/version-6.3/guides/error-handling.md","tags":[],"version":"6.3","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Error Handling"}}');var t=n(4848),a=n(8453);const i={sidebar_position:5,title:"Error Handling"},s="Error Handling Guide",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Error Types and Categories",id:"error-types-and-categories",level:2},{value:"User Errors",id:"user-errors",level:3},{value:"System Errors",id:"system-errors",level:3},{value:"Developer Errors",id:"developer-errors",level:3},{value:"Transaction Errors",id:"transaction-errors",level:3},{value:"Error Handling Architecture",id:"error-handling-architecture",level:2},{value:"Central Error Handler",id:"central-error-handler",level:3},{value:"Error Information Structure",id:"error-information-structure",level:3},{value:"User Error Handling",id:"user-error-handling",level:2},{value:"User-Friendly Error Messages",id:"user-friendly-error-messages",level:3},{value:"System Error Handling",id:"system-error-handling",level:2},{value:"Network and Service Errors",id:"network-and-service-errors",level:3},{value:"Developer Error Handling",id:"developer-error-handling",level:2},{value:"Configuration and Setup Errors",id:"configuration-and-setup-errors",level:3},{value:"Transaction Error Recovery",id:"transaction-error-recovery",level:2},{value:"Purchase Flow Recovery",id:"purchase-flow-recovery",level:3},{value:"Error Recovery Strategies",id:"error-recovery-strategies",level:2},{value:"Automatic Recovery",id:"automatic-recovery",level:3},{value:"Manual Recovery Options",id:"manual-recovery-options",level:3},{value:"Error Logging and Analytics",id:"error-logging-and-analytics",level:2},{value:"Comprehensive Error Logging",id:"comprehensive-error-logging",level:3},{value:"Error Metrics and Monitoring",id:"error-metrics-and-monitoring",level:3},{value:"Testing Error Scenarios",id:"testing-error-scenarios",level:2},{value:"Error Simulation",id:"error-simulation",level:3},{value:"Error Testing Framework",id:"error-testing-framework",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Prevention",id:"error-prevention",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function d(r){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"error-handling-guide",children:"Error Handling Guide"})}),"\n",(0,t.jsx)(e.p,{children:"Comprehensive guide to handling errors in flutter_inapp_purchase for robust and user-friendly applications."}),"\n",(0,t.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"Proper error handling is crucial for a smooth user experience in in-app purchase implementations. This guide covers error types, handling strategies, recovery mechanisms, and best practices."}),"\n",(0,t.jsx)(e.h2,{id:"error-types-and-categories",children:"Error Types and Categories"}),"\n",(0,t.jsx)(e.h3,{id:"user-errors",children:"User Errors"}),"\n",(0,t.jsx)(e.p,{children:"Errors caused by user actions or decisions:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"User cancelled purchase"}),"\n",(0,t.jsx)(e.li,{children:"Payment method issues"}),"\n",(0,t.jsx)(e.li,{children:"Parental controls/restrictions"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"system-errors",children:"System Errors"}),"\n",(0,t.jsx)(e.p,{children:"Errors related to system or service availability:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Network connectivity issues"}),"\n",(0,t.jsx)(e.li,{children:"Store service unavailable"}),"\n",(0,t.jsx)(e.li,{children:"Billing service unavailable"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"developer-errors",children:"Developer Errors"}),"\n",(0,t.jsx)(e.p,{children:"Errors due to configuration or implementation issues:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Product not found"}),"\n",(0,t.jsx)(e.li,{children:"Invalid product IDs"}),"\n",(0,t.jsx)(e.li,{children:"Missing permissions"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"transaction-errors",children:"Transaction Errors"}),"\n",(0,t.jsx)(e.p,{children:"Errors during the purchase process:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Payment processing failures"}),"\n",(0,t.jsx)(e.li,{children:"Transaction timeouts"}),"\n",(0,t.jsx)(e.li,{children:"Duplicate purchases"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"error-handling-architecture",children:"Error Handling Architecture"}),"\n",(0,t.jsx)(e.h3,{id:"central-error-handler",children:"Central Error Handler"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class IAPErrorHandler {\n  static void handleError(dynamic error, {\n    String? context,\n    Map<String, dynamic>? metadata,\n  }) {\n    // Log the error\n    _logError(error, context, metadata);\n    \n    // Determine error type\n    final errorInfo = _categorizeError(error);\n    \n    // Handle based on type\n    switch (errorInfo.category) {\n      case ErrorCategory.user:\n        _handleUserError(errorInfo);\n        break;\n      case ErrorCategory.system:\n        _handleSystemError(errorInfo);\n        break;\n      case ErrorCategory.developer:\n        _handleDeveloperError(errorInfo);\n        break;\n      case ErrorCategory.transaction:\n        _handleTransactionError(errorInfo);\n        break;\n      default:\n        _handleUnknownError(errorInfo);\n    }\n  }\n  \n  static ErrorInfo _categorizeError(dynamic error) {\n    if (error is PurchaseError) {\n      return _categorizePurchaseError(error);\n    } else if (error is PlatformException) {\n      return _categorizePlatformException(error);\n    } else {\n      return ErrorInfo(\n        category: ErrorCategory.unknown,\n        code: 'UNKNOWN',\n        message: error.toString(),\n        isRetryable: false,\n      );\n    }\n  }\n  \n  static ErrorInfo _categorizePurchaseError(PurchaseError error) {\n    switch (error.code) {\n      case ErrorCode.E_USER_CANCELLED:\n        return ErrorInfo(\n          category: ErrorCategory.user,\n          code: error.code.toString(),\n          message: 'Purchase was cancelled',\n          isRetryable: true,\n          userMessage: 'Purchase cancelled',\n        );\n        \n      case ErrorCode.E_NETWORK_ERROR:\n        return ErrorInfo(\n          category: ErrorCategory.system,\n          code: error.code.toString(),\n          message: error.message,\n          isRetryable: true,\n          userMessage: 'Please check your internet connection',\n        );\n        \n      case ErrorCode.E_DEVELOPER_ERROR:\n        return ErrorInfo(\n          category: ErrorCategory.developer,\n          code: error.code.toString(),\n          message: error.message,\n          isRetryable: false,\n          userMessage: 'Service temporarily unavailable',\n        );\n        \n      default:\n        return ErrorInfo(\n          category: ErrorCategory.unknown,\n          code: error.code.toString(),\n          message: error.message,\n          isRetryable: false,\n          userMessage: 'An error occurred. Please try again.',\n        );\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"error-information-structure",children:"Error Information Structure"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"enum ErrorCategory {\n  user,\n  system,\n  developer,\n  transaction,\n  unknown,\n}\n\nclass ErrorInfo {\n  final ErrorCategory category;\n  final String code;\n  final String message;\n  final bool isRetryable;\n  final String? userMessage;\n  final Duration? retryDelay;\n  final Map<String, dynamic>? metadata;\n  \n  ErrorInfo({\n    required this.category,\n    required this.code,\n    required this.message,\n    required this.isRetryable,\n    this.userMessage,\n    this.retryDelay,\n    this.metadata,\n  });\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"user-error-handling",children:"User Error Handling"}),"\n",(0,t.jsx)(e.h3,{id:"user-friendly-error-messages",children:"User-Friendly Error Messages"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class UserErrorHandler {\n  static void handleUserError(ErrorInfo error) {\n    switch (error.code) {\n      case 'E_USER_CANCELLED':\n        // Don't show error for user cancellation\n        break;\n        \n      case 'E_PAYMENT_NOT_ALLOWED':\n        _showErrorDialog(\n          title: 'Purchases Not Allowed',\n          message: 'In-app purchases are disabled on this device. '\n                   'Please check your device settings or parental controls.',\n          actions: [_createSettingsAction()],\n        );\n        break;\n        \n      case 'E_PRODUCT_ALREADY_OWNED':\n        _showErrorDialog(\n          title: 'Already Purchased',\n          message: 'You already own this item. Would you like to restore your purchases?',\n          actions: [_createRestoreAction(), _createCancelAction()],\n        );\n        break;\n        \n      default:\n        _showGenericErrorDialog(error.userMessage);\n    }\n  }\n  \n  static void _showErrorDialog({\n    required String title,\n    required String message,\n    List<Widget>? actions,\n  }) {\n    // Implementation depends on your UI framework\n    showDialog(\n      context: NavigationService.context,\n      builder: (context) => AlertDialog(\n        title: Text(title),\n        content: Text(message),\n        actions: actions ?? [_createOkAction()],\n      ),\n    );\n  }\n  \n  static Widget _createRestoreAction() {\n    return TextButton(\n      onPressed: () async {\n        Navigator.of(NavigationService.context).pop();\n        await PurchaseRestoreService.restorePurchases();\n      },\n      child: Text('Restore'),\n    );\n  }\n  \n  static Widget _createSettingsAction() {\n    return TextButton(\n      onPressed: () {\n        Navigator.of(NavigationService.context).pop();\n        // Open device settings if possible\n        _openDeviceSettings();\n      },\n      child: Text('Settings'),\n    );\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"system-error-handling",children:"System Error Handling"}),"\n",(0,t.jsx)(e.h3,{id:"network-and-service-errors",children:"Network and Service Errors"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class SystemErrorHandler {\n  static const int maxRetries = 3;\n  static const Duration baseDelay = Duration(seconds: 2);\n  \n  static Future<void> handleSystemError(\n    ErrorInfo error, {\n    required Function() retryOperation,\n  }) async {\n    switch (error.code) {\n      case 'E_NETWORK_ERROR':\n        await _handleNetworkError(retryOperation);\n        break;\n        \n      case 'E_SERVICE_ERROR':\n      case 'E_BILLING_UNAVAILABLE':\n        await _handleServiceError(error, retryOperation);\n        break;\n        \n      default:\n        _showSystemErrorDialog(error);\n    }\n  }\n  \n  static Future<void> _handleNetworkError(Function() retryOperation) async {\n    final hasConnection = await ConnectivityService.hasConnection();\n    \n    if (!hasConnection) {\n      _showNetworkErrorDialog();\n    } else {\n      // Network available but request failed - retry with backoff\n      await _retryWithBackoff(retryOperation);\n    }\n  }\n  \n  static Future<void> _handleServiceError(\n    ErrorInfo error,\n    Function() retryOperation,\n  ) async {\n    // Show loading indicator\n    LoadingService.show('Retrying...');\n    \n    try {\n      // Wait before retry\n      await Future.delayed(Duration(seconds: 5));\n      \n      // Retry the operation\n      await retryOperation();\n      \n    } catch (e) {\n      // Retry failed - show error to user\n      _showServiceUnavailableDialog();\n    } finally {\n      LoadingService.hide();\n    }\n  }\n  \n  static Future<void> _retryWithBackoff(Function() operation) async {\n    for (int attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        await operation();\n        return; // Success\n      } catch (e) {\n        if (attempt == maxRetries) {\n          // Final attempt failed\n          _showRetryFailedDialog();\n          break;\n        }\n        \n        // Wait with exponential backoff\n        final delay = baseDelay * (1 << (attempt - 1));\n        await Future.delayed(delay);\n      }\n    }\n  }\n  \n  static void _showNetworkErrorDialog() {\n    UserErrorHandler._showErrorDialog(\n      title: 'No Internet Connection',\n      message: 'Please check your internet connection and try again.',\n      actions: [\n        TextButton(\n          onPressed: () => Navigator.pop(NavigationService.context),\n          child: Text('OK'),\n        ),\n      ],\n    );\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"developer-error-handling",children:"Developer Error Handling"}),"\n",(0,t.jsx)(e.h3,{id:"configuration-and-setup-errors",children:"Configuration and Setup Errors"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class DeveloperErrorHandler {\n  static void handleDeveloperError(ErrorInfo error) {\n    // Log detailed error for developers\n    _logDeveloperError(error);\n    \n    switch (error.code) {\n      case 'E_NOT_INITIALIZED':\n        _handleNotInitialized();\n        break;\n        \n      case 'E_ITEM_UNAVAILABLE':\n        _handleItemUnavailable(error);\n        break;\n        \n      case 'E_DEVELOPER_ERROR':\n        _handleConfigurationError(error);\n        break;\n        \n      default:\n        _handleGenericDeveloperError(error);\n    }\n  }\n  \n  static Future<void> _handleNotInitialized() async {\n    print('IAP not initialized - attempting to initialize');\n    \n    try {\n      await FlutterInappPurchase.instance.initConnection();\n      print('IAP initialization successful');\n    } catch (e) {\n      print('IAP initialization failed: $e');\n      _showGenericErrorToUser();\n    }\n  }\n  \n  static void _handleItemUnavailable(ErrorInfo error) {\n    print('Product not available: ${error.message}');\n    \n    // Check if products are configured correctly\n    _validateProductConfiguration();\n    \n    // Show user-friendly message\n    UserErrorHandler._showErrorDialog(\n      title: 'Product Unavailable',\n      message: 'This item is currently not available. Please try again later.',\n    );\n  }\n  \n  static void _handleConfigurationError(ErrorInfo error) {\n    print('Configuration error: ${error.message}');\n    \n    // Don't expose technical details to users\n    _showGenericErrorToUser();\n    \n    // Report to crash analytics\n    CrashReporting.recordError(\n      'IAP Configuration Error',\n      error.message,\n      error.metadata,\n    );\n  }\n  \n  static void _validateProductConfiguration() {\n    // Validate that products are configured in stores\n    const expectedProducts = [\n      'com.example.premium',\n      'com.example.remove_ads',\n    ];\n    \n    print('Expected products: $expectedProducts');\n    print('Verify these are configured in App Store Connect and Play Console');\n  }\n  \n  static void _showGenericErrorToUser() {\n    UserErrorHandler._showErrorDialog(\n      title: 'Service Unavailable',\n      message: 'The service is temporarily unavailable. Please try again later.',\n    );\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"transaction-error-recovery",children:"Transaction Error Recovery"}),"\n",(0,t.jsx)(e.h3,{id:"purchase-flow-recovery",children:"Purchase Flow Recovery"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class TransactionErrorRecovery {\n  static Future<void> handleTransactionError(\n    ErrorInfo error,\n    String productId,\n  ) async {\n    switch (error.code) {\n      case 'E_PURCHASE_FAILED':\n        await _handlePurchaseFailure(productId);\n        break;\n        \n      case 'E_TRANSACTION_TIMEOUT':\n        await _handleTransactionTimeout(productId);\n        break;\n        \n      case 'E_DUPLICATE_PURCHASE':\n        await _handleDuplicatePurchase(productId);\n        break;\n        \n      default:\n        await _handleGenericTransactionError(error, productId);\n    }\n  }\n  \n  static Future<void> _handlePurchaseFailure(String productId) async {\n    // Check if there are pending transactions\n    final pendingPurchases = await FlutterInappPurchase.instance\n        .getAvailablePurchases();\n    \n    final pendingForProduct = pendingPurchases\n        .where((p) => p.productId == productId)\n        .toList();\n    \n    if (pendingForProduct.isNotEmpty) {\n      // There's a pending purchase - try to complete it\n      await _completePendingPurchase(pendingForProduct.first);\n    } else {\n      // No pending purchase - safe to retry\n      _showRetryPurchaseDialog(productId);\n    }\n  }\n  \n  static Future<void> _handleTransactionTimeout(String productId) async {\n    // Show message that transaction is still processing\n    UserErrorHandler._showErrorDialog(\n      title: 'Transaction Processing',\n      message: 'Your purchase is still being processed. '\n               'Please wait a moment and check your purchases.',\n      actions: [\n        TextButton(\n          onPressed: () async {\n            Navigator.pop(NavigationService.context);\n            await _checkPurchaseStatus(productId);\n          },\n          child: Text('Check Status'),\n        ),\n        TextButton(\n          onPressed: () => Navigator.pop(NavigationService.context),\n          child: Text('OK'),\n        ),\n      ],\n    );\n  }\n  \n  static Future<void> _completePendingPurchase(Purchase purchase) async {\n    try {\n      // Verify the purchase\n      final isValid = await PurchaseValidator.validate(purchase);\n      \n      if (isValid) {\n        // Deliver content\n        await ContentDelivery.deliver(purchase.productId);\n        \n        // Finish transaction\n        await FlutterInappPurchase.instance.finishTransaction(purchase);\n        \n        // Notify user\n        _showPurchaseCompletedMessage();\n      } else {\n        _showPurchaseValidationFailedMessage();\n      }\n    } catch (e) {\n      print('Error completing pending purchase: $e');\n      _showGenericErrorToUser();\n    }\n  }\n  \n  static Future<void> _checkPurchaseStatus(String productId) async {\n    LoadingService.show('Checking purchase status...');\n    \n    try {\n      final purchases = await FlutterInappPurchase.instance\n          .getAvailablePurchases();\n      \n      final purchase = purchases\n          .firstWhere((p) => p.productId == productId, orElse: () => null);\n      \n      if (purchase != null) {\n        await _completePendingPurchase(purchase);\n      } else {\n        _showNoPurchaseFoundMessage();\n      }\n    } catch (e) {\n      _showCheckStatusErrorMessage();\n    } finally {\n      LoadingService.hide();\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"error-recovery-strategies",children:"Error Recovery Strategies"}),"\n",(0,t.jsx)(e.h3,{id:"automatic-recovery",children:"Automatic Recovery"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class AutomaticErrorRecovery {\n  static final Map<String, int> _retryCount = {};\n  static const int maxAutoRetries = 2;\n  \n  static Future<bool> attemptRecovery(\n    ErrorInfo error,\n    String operationId,\n    Function() operation,\n  ) async {\n    if (!error.isRetryable) {\n      return false;\n    }\n    \n    final retries = _retryCount[operationId] ?? 0;\n    if (retries >= maxAutoRetries) {\n      return false;\n    }\n    \n    _retryCount[operationId] = retries + 1;\n    \n    try {\n      // Wait before retry\n      if (error.retryDelay != null) {\n        await Future.delayed(error.retryDelay!);\n      }\n      \n      // Attempt recovery based on error type\n      await _performRecovery(error);\n      \n      // Retry original operation\n      await operation();\n      \n      // Success - clear retry count\n      _retryCount.remove(operationId);\n      return true;\n      \n    } catch (e) {\n      print('Auto recovery failed: $e');\n      return false;\n    }\n  }\n  \n  static Future<void> _performRecovery(ErrorInfo error) async {\n    switch (error.category) {\n      case ErrorCategory.system:\n        await _recoverFromSystemError(error);\n        break;\n      case ErrorCategory.developer:\n        await _recoverFromDeveloperError(error);\n        break;\n      default:\n        // No automatic recovery for other types\n        break;\n    }\n  }\n  \n  static Future<void> _recoverFromSystemError(ErrorInfo error) async {\n    switch (error.code) {\n      case 'E_NOT_INITIALIZED':\n        await FlutterInappPurchase.instance.initConnection();\n        break;\n      case 'E_NETWORK_ERROR':\n        await _waitForNetworkRecovery();\n        break;\n    }\n  }\n  \n  static Future<void> _waitForNetworkRecovery() async {\n    // Wait for network to become available\n    const maxWait = Duration(seconds: 30);\n    const checkInterval = Duration(seconds: 2);\n    \n    final stopTime = DateTime.now().add(maxWait);\n    \n    while (DateTime.now().isBefore(stopTime)) {\n      if (await ConnectivityService.hasConnection()) {\n        return; // Network recovered\n      }\n      await Future.delayed(checkInterval);\n    }\n    \n    throw Exception('Network recovery timeout');\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"manual-recovery-options",children:"Manual Recovery Options"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class ManualRecoveryOptions {\n  static void showRecoveryDialog(ErrorInfo error, String operationId) {\n    final recoveryOptions = _getRecoveryOptions(error);\n    \n    showDialog(\n      context: NavigationService.context,\n      builder: (context) => AlertDialog(\n        title: Text('Something went wrong'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text(error.userMessage ?? 'An error occurred'),\n            SizedBox(height: 16),\n            Text(\n              'What would you like to do?',\n              style: TextStyle(fontWeight: FontWeight.bold),\n            ),\n          ],\n        ),\n        actions: recoveryOptions.map((option) => \n          TextButton(\n            onPressed: () {\n              Navigator.pop(context);\n              option.action();\n            },\n            child: Text(option.label),\n          )\n        ).toList(),\n      ),\n    );\n  }\n  \n  static List<RecoveryOption> _getRecoveryOptions(ErrorInfo error) {\n    final options = <RecoveryOption>[];\n    \n    // Always offer retry for retryable errors\n    if (error.isRetryable) {\n      options.add(RecoveryOption(\n        label: 'Try Again',\n        action: () => _retryLastOperation(),\n      ));\n    }\n    \n    // Error-specific options\n    switch (error.category) {\n      case ErrorCategory.user:\n        if (error.code == 'E_PRODUCT_ALREADY_OWNED') {\n          options.add(RecoveryOption(\n            label: 'Restore Purchases',\n            action: () => PurchaseRestoreService.restorePurchases(),\n          ));\n        }\n        break;\n        \n      case ErrorCategory.system:\n        options.add(RecoveryOption(\n          label: 'Check Connection',\n          action: () => ConnectivityService.showConnectionStatus(),\n        ));\n        break;\n    }\n    \n    // Always offer contact support\n    options.add(RecoveryOption(\n      label: 'Contact Support',\n      action: () => SupportService.openSupportChat(),\n    ));\n    \n    return options;\n  }\n}\n\nclass RecoveryOption {\n  final String label;\n  final VoidCallback action;\n  \n  RecoveryOption({required this.label, required this.action});\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"error-logging-and-analytics",children:"Error Logging and Analytics"}),"\n",(0,t.jsx)(e.h3,{id:"comprehensive-error-logging",children:"Comprehensive Error Logging"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class ErrorLogging {\n  static void logError(\n    dynamic error, {\n    String? context,\n    Map<String, dynamic>? metadata,\n    StackTrace? stackTrace,\n  }) {\n    final errorData = {\n      'error': error.toString(),\n      'context': context,\n      'timestamp': DateTime.now().toIso8601String(),\n      'platform': Platform.isIOS ? 'ios' : 'android',\n      'app_version': _getAppVersion(),\n      'user_id': _getUserId(),\n      'device_info': _getDeviceInfo(),\n      'metadata': metadata,\n    };\n    \n    // Log to console in debug mode\n    if (kDebugMode) {\n      print('IAP Error: ${json.encode(errorData)}');\n      if (stackTrace != null) {\n        print('Stack trace: $stackTrace');\n      }\n    }\n    \n    // Send to analytics in production\n    if (kReleaseMode) {\n      AnalyticsService.logError('iap_error', errorData);\n    }\n    \n    // Send to crash reporting\n    CrashReporting.recordError(\n      error,\n      stackTrace,\n      context: errorData,\n    );\n  }\n  \n  static void logErrorPattern(String pattern, Map<String, dynamic> data) {\n    AnalyticsService.logEvent('iap_error_pattern', {\n      'pattern': pattern,\n      'count': data['count'],\n      'first_occurrence': data['first_occurrence'],\n      'last_occurrence': data['last_occurrence'],\n    });\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"error-metrics-and-monitoring",children:"Error Metrics and Monitoring"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class ErrorMetrics {\n  static final Map<String, int> _errorCounts = {};\n  static final Map<String, DateTime> _firstOccurrence = {};\n  static Timer? _reportingTimer;\n  \n  static void recordError(String errorCode) {\n    _errorCounts[errorCode] = (_errorCounts[errorCode] ?? 0) + 1;\n    _firstOccurrence[errorCode] ??= DateTime.now();\n    \n    _scheduleReporting();\n  }\n  \n  static void _scheduleReporting() {\n    _reportingTimer?.cancel();\n    _reportingTimer = Timer(Duration(minutes: 5), _reportMetrics);\n  }\n  \n  static void _reportMetrics() {\n    for (final entry in _errorCounts.entries) {\n      final errorCode = entry.key;\n      final count = entry.value;\n      \n      ErrorLogging.logErrorPattern(errorCode, {\n        'count': count,\n        'first_occurrence': _firstOccurrence[errorCode]?.toIso8601String(),\n        'last_occurrence': DateTime.now().toIso8601String(),\n      });\n    }\n    \n    // Reset counters\n    _errorCounts.clear();\n    _firstOccurrence.clear();\n  }\n  \n  static Map<String, int> getErrorSummary() {\n    return Map.from(_errorCounts);\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"testing-error-scenarios",children:"Testing Error Scenarios"}),"\n",(0,t.jsx)(e.h3,{id:"error-simulation",children:"Error Simulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class ErrorSimulator {\n  static bool enableSimulation = false;\n  static double simulationRate = 0.1; // 10% error rate\n  \n  static void maybeThrowTestError(String operation) {\n    if (!enableSimulation) return;\n    if (Random().nextDouble() > simulationRate) return;\n    \n    final errorTypes = [\n      PurchaseError(\n        code: ErrorCode.E_NETWORK_ERROR,\n        message: 'Simulated network error',\n        platform: IAPPlatform.ios,\n      ),\n      PurchaseError(\n        code: ErrorCode.E_SERVICE_ERROR,\n        message: 'Simulated service error',\n        platform: IAPPlatform.android,\n      ),\n    ];\n    \n    final randomError = errorTypes[Random().nextInt(errorTypes.length)];\n    throw randomError;\n  }\n  \n  static Future<void> simulateSpecificError(ErrorCode errorCode) async {\n    throw PurchaseError(\n      code: errorCode,\n      message: 'Simulated error: $errorCode',\n      platform: Platform.isIOS ? IAPPlatform.ios : IAPPlatform.android,\n    );\n  }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"error-testing-framework",children:"Error Testing Framework"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-dart",children:"class ErrorTestSuite {\n  static Future<void> runAllTests() async {\n    await testUserCancellationError();\n    await testNetworkError();\n    await testServiceUnavailableError();\n    await testProductNotFoundError();\n    await testDuplicatePurchaseError();\n    \n    print('All error handling tests completed');\n  }\n  \n  static Future<void> testUserCancellationError() async {\n    try {\n      await ErrorSimulator.simulateSpecificError(ErrorCode.E_USER_CANCELLED);\n      assert(false, 'Expected error was not thrown');\n    } catch (e) {\n      IAPErrorHandler.handleError(e, context: 'test_user_cancellation');\n      print('\u2713 User cancellation error handled correctly');\n    }\n  }\n  \n  static Future<void> testNetworkError() async {\n    try {\n      await ErrorSimulator.simulateSpecificError(ErrorCode.E_NETWORK_ERROR);\n      assert(false, 'Expected error was not thrown');\n    } catch (e) {\n      IAPErrorHandler.handleError(e, context: 'test_network_error');\n      print('\u2713 Network error handled correctly');\n    }\n  }\n  \n  // Add more test methods...\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Categorize Errors"}),": Group errors by type for appropriate handling"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"User-Friendly Messages"}),": Show helpful messages, not technical details"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Automatic Recovery"}),": Implement smart retry logic for recoverable errors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Log Everything"}),": Comprehensive logging for debugging and analytics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Test Error Scenarios"}),": Test all error paths in your application"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Graceful Degradation"}),": App should remain functional despite IAP errors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Monitor Patterns"}),": Track error patterns to identify systemic issues"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Provide Alternatives"}),": Offer workarounds when possible"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"error-prevention",children:"Error Prevention"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Validate Early"}),": Check prerequisites before attempting operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Handle State"}),": Manage IAP state carefully to prevent errors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Queue Operations"}),": Prevent concurrent IAP operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Cache Results"}),": Reduce API calls that might fail"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Update Dependencies"}),": Keep IAP libraries up to date"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/docs/6.3/guides/purchases",children:"Purchases Guide"})," - Purchase implementation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/docs/6.3/guides/subscriptions",children:"Subscriptions Guide"})," - Subscription handling"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"/docs/6.3/api/types/error-codes",children:"API Types"})," - Error code reference"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:"./testing.md",children:"Testing Guide"})," - Testing error scenarios"]}),"\n"]})]})}function u(r={}){const{wrapper:e}={...(0,a.R)(),...r.components};return e?(0,t.jsx)(e,{...r,children:(0,t.jsx)(d,{...r})}):d(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>i,x:()=>s});var o=n(6540);const t={},a=o.createContext(t);function i(r){const e=o.useContext(a);return o.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function s(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:i(r.components),o.createElement(a.Provider,{value:e},r.children)}}}]);