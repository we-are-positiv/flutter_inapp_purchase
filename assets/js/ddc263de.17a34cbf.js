"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[9200],{3830:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"examples/complete-implementation","title":"Complete Implementation","description":"A comprehensive, production-ready implementation with all best practices for a robust in-app purchase system.","source":"@site/versioned_docs/version-6.3/examples/complete-implementation.md","sourceDirName":"examples","slug":"/examples/complete-implementation","permalink":"/docs/6.3/examples/complete-implementation","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/versioned_docs/version-6.3/examples/complete-implementation.md","tags":[],"version":"6.3","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Complete Implementation"},"sidebar":"docsSidebar","previous":{"title":"Subscription Store","permalink":"/docs/6.3/examples/subscription-store"},"next":{"title":"Sponsors","permalink":"/docs/6.3/sponsors"}}');var i=t(4848),s=t(8453);const a={sidebar_position:3,title:"Complete Implementation"},o="Complete Production-Ready Implementation",c={},l=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Complete Store Implementation",id:"complete-store-implementation",level:2},{value:"1. IAP Service",id:"1-iap-service",level:3},{value:"2. Store Provider",id:"2-store-provider",level:3},{value:"3. Store UI",id:"3-store-ui",level:3},{value:"4. Configuration &amp; Security",id:"4-configuration--security",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"Production Considerations",id:"production-considerations",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"complete-production-ready-implementation",children:"Complete Production-Ready Implementation"})}),"\n",(0,i.jsx)(n.p,{children:"A comprehensive, production-ready implementation with all best practices for a robust in-app purchase system."}),"\n",(0,i.jsx)(n.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(n.p,{children:"This implementation includes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"State management with provider"}),"\n",(0,i.jsx)(n.li,{children:"Server-side receipt validation"}),"\n",(0,i.jsx)(n.li,{children:"Offline support with local caching"}),"\n",(0,i.jsx)(n.li,{children:"Comprehensive error handling"}),"\n",(0,i.jsx)(n.li,{children:"Analytics tracking"}),"\n",(0,i.jsx)(n.li,{children:"Security best practices"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"complete-store-implementation",children:"Complete Store Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"1-iap-service",children:"1. IAP Service"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// services/iap_service.dart\nimport 'package:flutter_inapp_purchase/flutter_inapp_purchase.dart';\nimport 'dart:async';\nimport 'dart:io';\nimport 'package:http/http.dart' as http;\nimport 'dart:convert';\n\nclass IAPService {\n  static final IAPService _instance = IAPService._internal();\n  factory IAPService() => _instance;\n  IAPService._internal();\n\n  StreamSubscription? _purchaseUpdatedSubscription;\n  StreamSubscription? _purchaseErrorSubscription;\n\n  final StreamController<PurchaseUpdate> _purchaseController =\n      StreamController.broadcast();\n\n  Stream<PurchaseUpdate> get purchaseStream => _purchaseController.stream;\n\n  Future<bool> initialize() async {\n    try {\n      final result = await FlutterInappPurchase.instance.initialize();\n\n      _purchaseUpdatedSubscription = FlutterInappPurchase\n          .purchaseUpdated.listen(_handlePurchaseUpdate);\n\n      _purchaseErrorSubscription = FlutterInappPurchase\n          .purchaseError.listen(_handlePurchaseError);\n\n      return result != null;\n    } catch (e) {\n      print('IAP initialization failed: $e');\n      return false;\n    }\n  }\n\n  void _handlePurchaseUpdate(PurchasedItem? item) async {\n    if (item == null) return;\n\n    try {\n      // Validate receipt server-side\n      final validationResult = await _validatePurchase(item);\n\n      if (validationResult.isValid) {\n        // Deliver content\n        await _deliverPurchase(item, validationResult);\n\n        // Complete transaction\n        await _completeTransaction(item);\n\n        _purchaseController.add(PurchaseUpdate(\n          item: item,\n          status: PurchaseStatus.success,\n          validationResult: validationResult,\n        ));\n      } else {\n        _purchaseController.add(PurchaseUpdate(\n          item: item,\n          status: PurchaseStatus.validationFailed,\n          error: 'Receipt validation failed',\n        ));\n      }\n    } catch (e) {\n      _purchaseController.add(PurchaseUpdate(\n        item: item,\n        status: PurchaseStatus.error,\n        error: e.toString(),\n      ));\n    }\n  }\n\n  void _handlePurchaseError(PurchasedItem? item) {\n    _purchaseController.add(PurchaseUpdate(\n      item: item,\n      status: PurchaseStatus.error,\n      error: 'Purchase failed',\n    ));\n  }\n\n  Future<List<IapItem>> getProducts(List<String> productIds) async {\n    try {\n      return await FlutterInappPurchase.instance.requestProducts(skus: productIds, type: 'inapp');\n    } catch (e) {\n      print('Failed to get products: $e');\n      return [];\n    }\n  }\n\n  Future<List<IapItem>> getSubscriptions(List<String> subscriptionIds) async {\n    try {\n      return await FlutterInappPurchase.instance.requestProducts(skus: subscriptionIds, type: 'subs');\n    } catch (e) {\n      print('Failed to get subscriptions: $e');\n      return [];\n    }\n  }\n\n  Future<void> requestPurchase(String productId) async {\n    await FlutterInappPurchase.instance.requestPurchase(productId);\n  }\n\n  Future<void> requestSubscription(String productId) async {\n    await FlutterInappPurchase.instance.requestSubscription(productId);\n  }\n\n  Future<List<PurchasedItem>> getAvailablePurchases() async {\n    try {\n      final purchases = await FlutterInappPurchase.instance\n          .getAvailablePurchases();\n      return purchases ?? [];\n    } catch (e) {\n      print('Failed to get available purchases: $e');\n      return [];\n    }\n  }\n\n  Future<ValidationResult> _validatePurchase(PurchasedItem item) async {\n    try {\n      String? receipt;\n\n      if (Platform.isIOS) {\n        receipt = await FlutterInappPurchase.instance.getReceiptData();\n      } else {\n        receipt = item.purchaseToken;\n      }\n\n      final response = await http.post(\n        Uri.parse('${Config.baseUrl}/validate-purchase'),\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': 'Bearer ${await AuthService().getToken()}',\n        },\n        body: jsonEncode({\n          'platform': Platform.isIOS ? 'ios' : 'android',\n          'productId': item.productId,\n          'transactionId': item.transactionId,\n          'receipt': receipt,\n          'userId': await UserService().getCurrentUserId(),\n        }),\n      );\n\n      if (response.statusCode == 200) {\n        final data = jsonDecode(response.body);\n        return ValidationResult.fromJson(data);\n      } else {\n        return ValidationResult.invalid('Server validation failed');\n      }\n    } catch (e) {\n      return ValidationResult.invalid(e.toString());\n    }\n  }\n\n  Future<void> _deliverPurchase(\n    PurchasedItem item,\n    ValidationResult validationResult\n  ) async {\n    // Update local storage\n    await LocalStorage().savePurchase(item);\n\n    // Track analytics\n    AnalyticsService().trackPurchase(item);\n\n    // Grant content/features\n    await ContentService().grantAccess(\n      item.productId!,\n      validationResult.purchaseData\n    );\n  }\n\n  Future<void> _completeTransaction(PurchasedItem item) async {\n    if (Platform.isIOS) {\n      await FlutterInappPurchase.instance.finishTransaction(item);\n    } else if (Platform.isAndroid) {\n      final isConsumable = ProductConfig.isConsumable(item.productId!);\n\n      if (isConsumable) {\n        await FlutterInappPurchase.instance.consumePurchase(\n          purchaseToken: item.purchaseToken!,\n        );\n      } else {\n        await FlutterInappPurchase.instance.acknowledgePurchase(\n          purchaseToken: item.purchaseToken!,\n        );\n      }\n    }\n  }\n\n  void dispose() {\n    _purchaseUpdatedSubscription?.cancel();\n    _purchaseErrorSubscription?.cancel();\n    _purchaseController.close();\n  }\n}\n\n// Data models\nclass PurchaseUpdate {\n  final PurchasedItem? item;\n  final PurchaseStatus status;\n  final String? error;\n  final ValidationResult? validationResult;\n\n  PurchaseUpdate({\n    this.item,\n    required this.status,\n    this.error,\n    this.validationResult,\n  });\n}\n\nenum PurchaseStatus {\n  success,\n  error,\n  validationFailed,\n  cancelled,\n}\n\nclass ValidationResult {\n  final bool isValid;\n  final String? error;\n  final Map<String, dynamic>? purchaseData;\n\n  ValidationResult.valid(this.purchaseData)\n    : isValid = true, error = null;\n\n  ValidationResult.invalid(this.error)\n    : isValid = false, purchaseData = null;\n\n  factory ValidationResult.fromJson(Map<String, dynamic> json) {\n    return ValidationResult.valid(json['purchaseData']);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-store-provider",children:"2. Store Provider"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// providers/store_provider.dart\nimport 'package:flutter/foundation.dart';\nimport '../services/iap_service.dart';\n\nclass StoreProvider extends ChangeNotifier {\n  final IAPService _iapService = IAPService();\n\n  List<IapItem> _products = [];\n  List<IapItem> _subscriptions = [];\n  List<PurchasedItem> _purchases = [];\n\n  bool _isInitialized = false;\n  bool _isLoading = false;\n  String? _error;\n\n  // Getters\n  List<IapItem> get products => _products;\n  List<IapItem> get subscriptions => _subscriptions;\n  List<PurchasedItem> get purchases => _purchases;\n  bool get isInitialized => _isInitialized;\n  bool get isLoading => _isLoading;\n  String? get error => _error;\n\n  Future<void> initialize() async {\n    _setLoading(true);\n\n    try {\n      _isInitialized = await _iapService.initialize();\n\n      if (_isInitialized) {\n        // Listen to purchase updates\n        _iapService.purchaseStream.listen(_handlePurchaseUpdate);\n\n        // Load initial data\n        await loadProducts();\n        await loadPurchases();\n      }\n\n      _error = null;\n    } catch (e) {\n      _error = e.toString();\n    } finally {\n      _setLoading(false);\n    }\n  }\n\n  Future<void> loadProducts() async {\n    try {\n      final productIds = ProductConfig.getAllProductIds();\n      final subscriptionIds = ProductConfig.getAllSubscriptionIds();\n\n      final results = await Future.wait([\n        _iapService.getProducts(productIds),\n        _iapService.getSubscriptions(subscriptionIds),\n      ]);\n\n      _products = results[0];\n      _subscriptions = results[1];\n\n      notifyListeners();\n    } catch (e) {\n      _error = e.toString();\n      notifyListeners();\n    }\n  }\n\n  Future<void> loadPurchases() async {\n    try {\n      _purchases = await _iapService.getAvailablePurchases();\n      notifyListeners();\n    } catch (e) {\n      _error = e.toString();\n      notifyListeners();\n    }\n  }\n\n  Future<void> purchaseProduct(String productId) async {\n    try {\n      _error = null;\n      await _iapService.requestPurchase(productId);\n    } catch (e) {\n      _error = e.toString();\n      notifyListeners();\n    }\n  }\n\n  Future<void> purchaseSubscription(String productId) async {\n    try {\n      _error = null;\n      await _iapService.requestSubscription(productId);\n    } catch (e) {\n      _error = e.toString();\n      notifyListeners();\n    }\n  }\n\n  bool isPurchased(String productId) {\n    return _purchases.any((p) => p.productId == productId);\n  }\n\n  bool isSubscriptionActive(String productId) {\n    final purchase = _purchases.firstWhere(\n      (p) => p.productId == productId,\n      orElse: () => PurchasedItem(),\n    );\n\n    // Check if subscription is still valid\n    // You'd implement expiration checking here\n    return purchase.productId != null;\n  }\n\n  void _handlePurchaseUpdate(PurchaseUpdate update) {\n    switch (update.status) {\n      case PurchaseStatus.success:\n        loadPurchases(); // Refresh purchases\n        break;\n      case PurchaseStatus.error:\n      case PurchaseStatus.validationFailed:\n        _error = update.error;\n        notifyListeners();\n        break;\n      case PurchaseStatus.cancelled:\n        // Handle cancellation\n        break;\n    }\n  }\n\n  void _setLoading(bool loading) {\n    _isLoading = loading;\n    notifyListeners();\n  }\n\n  @override\n  void dispose() {\n    _iapService.dispose();\n    super.dispose();\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"3-store-ui",children:"3. Store UI"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// screens/store_screen.dart\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport '../providers/store_provider.dart';\n\nclass StoreScreen extends StatefulWidget {\n  @override\n  _StoreScreenState createState() => _StoreScreenState();\n}\n\nclass _StoreScreenState extends State<StoreScreen>\n    with SingleTickerProviderStateMixin {\n\n  late TabController _tabController;\n\n  @override\n  void initState() {\n    super.initState();\n    _tabController = TabController(length: 2, vsync: this);\n\n    // Initialize store if not already done\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      final store = Provider.of<StoreProvider>(context, listen: false);\n      if (!store.isInitialized) {\n        store.initialize();\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    _tabController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Store'),\n        bottom: TabBar(\n          controller: _tabController,\n          tabs: [\n            Tab(text: 'Products'),\n            Tab(text: 'Subscriptions'),\n          ],\n        ),\n        actions: [\n          IconButton(\n            icon: Icon(Icons.restore),\n            onPressed: _restorePurchases,\n          ),\n        ],\n      ),\n      body: Consumer<StoreProvider>(\n        builder: (context, store, child) {\n          if (!store.isInitialized) {\n            return _buildInitializingView();\n          }\n\n          if (store.isLoading) {\n            return _buildLoadingView();\n          }\n\n          if (store.error != null) {\n            return _buildErrorView(store.error!, store);\n          }\n\n          return TabBarView(\n            controller: _tabController,\n            children: [\n              _buildProductsTab(store),\n              _buildSubscriptionsTab(store),\n            ],\n          );\n        },\n      ),\n    );\n  }\n\n  Widget _buildInitializingView() {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          CircularProgressIndicator(),\n          SizedBox(height: 16),\n          Text('Initializing store...'),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildLoadingView() {\n    return Center(child: CircularProgressIndicator());\n  }\n\n  Widget _buildErrorView(String error, StoreProvider store) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Icon(Icons.error_outline, size: 64, color: Colors.red),\n          SizedBox(height: 16),\n          Text(\n            'Store Error',\n            style: Theme.of(context).textTheme.headlineSmall,\n          ),\n          SizedBox(height: 8),\n          Text(\n            error,\n            textAlign: TextAlign.center,\n            style: TextStyle(color: Colors.grey[600]),\n          ),\n          SizedBox(height: 24),\n          ElevatedButton(\n            onPressed: () => store.initialize(),\n            child: Text('Retry'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildProductsTab(StoreProvider store) {\n    if (store.products.isEmpty) {\n      return Center(child: Text('No products available'));\n    }\n\n    return ListView.builder(\n      padding: EdgeInsets.all(16),\n      itemCount: store.products.length,\n      itemBuilder: (context, index) {\n        final product = store.products[index];\n        final isPurchased = store.isPurchased(product.productId!);\n\n        return Card(\n          child: ListTile(\n            title: Text(product.title ?? product.productId!),\n            subtitle: Text(product.description ?? ''),\n            trailing: isPurchased\n                ? Chip(\n                    label: Text('OWNED'),\n                    backgroundColor: Colors.green,\n                    labelStyle: TextStyle(color: Colors.white),\n                  )\n                : ElevatedButton(\n                    onPressed: () => store.purchaseProduct(product.productId!),\n                    child: Text(product.localizedPrice ?? 'Buy'),\n                  ),\n          ),\n        );\n      },\n    );\n  }\n\n  Widget _buildSubscriptionsTab(StoreProvider store) {\n    if (store.subscriptions.isEmpty) {\n      return Center(child: Text('No subscriptions available'));\n    }\n\n    return ListView.builder(\n      padding: EdgeInsets.all(16),\n      itemCount: store.subscriptions.length,\n      itemBuilder: (context, index) {\n        final subscription = store.subscriptions[index];\n        final isActive = store.isSubscriptionActive(subscription.productId!);\n\n        return Card(\n          child: ListTile(\n            title: Text(subscription.title ?? subscription.productId!),\n            subtitle: Text(subscription.description ?? ''),\n            trailing: isActive\n                ? Chip(\n                    label: Text('ACTIVE'),\n                    backgroundColor: Colors.blue,\n                    labelStyle: TextStyle(color: Colors.white),\n                  )\n                : ElevatedButton(\n                    onPressed: () => store.purchaseSubscription(\n                      subscription.productId!\n                    ),\n                    child: Text(subscription.localizedPrice ?? 'Subscribe'),\n                  ),\n          ),\n        );\n      },\n    );\n  }\n\n  void _restorePurchases() async {\n    final store = Provider.of<StoreProvider>(context, listen: false);\n    await store.loadPurchases();\n\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(content: Text('Purchases restored')),\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"4-configuration--security",children:"4. Configuration & Security"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// config/product_config.dart\nclass ProductConfig {\n  static const Map<String, ProductInfo> _products = {\n    'coins_100': ProductInfo(type: ProductType.consumable, value: 100),\n    'coins_500': ProductInfo(type: ProductType.consumable, value: 500),\n    'remove_ads': ProductInfo(type: ProductType.nonConsumable),\n    'premium_monthly': ProductInfo(type: ProductType.subscription),\n    'premium_yearly': ProductInfo(type: ProductType.subscription),\n  };\n\n  static List<String> getAllProductIds() {\n    return _products.entries\n        .where((e) => e.value.type != ProductType.subscription)\n        .map((e) => e.key)\n        .toList();\n  }\n\n  static List<String> getAllSubscriptionIds() {\n    return _products.entries\n        .where((e) => e.value.type == ProductType.subscription)\n        .map((e) => e.key)\n        .toList();\n  }\n\n  static bool isConsumable(String productId) {\n    return _products[productId]?.type == ProductType.consumable;\n  }\n\n  static ProductInfo? getProductInfo(String productId) {\n    return _products[productId];\n  }\n}\n\nclass ProductInfo {\n  final ProductType type;\n  final int? value;\n\n  const ProductInfo({\n    required this.type,\n    this.value,\n  });\n}\n\nenum ProductType { consumable, nonConsumable, subscription }\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Server-Side Validation"}),": All receipts validated on secure backend"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"User Authentication"}),": Purchases tied to authenticated user accounts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Secure Storage"}),": Purchase data encrypted locally"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Network Security"}),": HTTPS only, certificate pinning"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Obfuscation"}),": Sensitive code obfuscated in production builds"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"production-considerations",children:"Production Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement proper logging and crash reporting"}),"\n",(0,i.jsx)(n.li,{children:"Add comprehensive analytics tracking"}),"\n",(0,i.jsx)(n.li,{children:"Handle network failures gracefully"}),"\n",(0,i.jsx)(n.li,{children:"Implement offline mode with sync"}),"\n",(0,i.jsx)(n.li,{children:"Add proper loading states throughout"}),"\n",(0,i.jsx)(n.li,{children:"Test thoroughly with different devices and conditions"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This implementation provides a robust foundation for production apps with complex IAP requirements."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);