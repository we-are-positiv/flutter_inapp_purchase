"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[389],{2085:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guides/faq","title":"FAQ","description":"Common questions and answers about flutterinapppurchase v6.0.0, covering implementation, platform differences, best practices, and migration.","source":"@site/docs/guides/faq.md","sourceDirName":"guides","slug":"/guides/faq","permalink":"/docs/guides/faq","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/docs/guides/faq.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"FAQ"},"sidebar":"docsSidebar","previous":{"title":"Troubleshooting","permalink":"/docs/guides/troubleshooting"},"next":{"title":"Migration Guide","permalink":"/docs/migration/from-v5"}}');var s=r(4848),i=r(8453);const a={sidebar_position:10,title:"FAQ"},o="Frequently Asked Questions",c={},d=[{value:"General Questions",id:"general-questions",level:2},{value:"What is flutter_inapp_purchase?",id:"what-is-flutter_inapp_purchase",level:3},{value:"Which platforms are supported?",id:"which-platforms-are-supported",level:3},{value:"What&#39;s new in v6.0.0?",id:"whats-new-in-v600",level:3},{value:"Implementation Questions",id:"implementation-questions",level:2},{value:"How do I get started?",id:"how-do-i-get-started",level:3},{value:"How do I handle different product types?",id:"how-do-i-handle-different-product-types",level:3},{value:"How do I restore purchases?",id:"how-do-i-restore-purchases",level:3},{value:"How do I validate receipts?",id:"how-do-i-validate-receipts",level:3},{value:"Platform Differences",id:"platform-differences",level:2},{value:"What are the key differences between iOS and Android?",id:"what-are-the-key-differences-between-ios-and-android",level:3},{value:"How do I handle platform-specific features?",id:"how-do-i-handle-platform-specific-features",level:3},{value:"Do I need different product IDs for each platform?",id:"do-i-need-different-product-ids-for-each-platform",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Should I verify purchases client-side or server-side?",id:"should-i-verify-purchases-client-side-or-server-side",level:3},{value:"How should I handle errors?",id:"how-should-i-handle-errors",level:3},{value:"How do I test purchases?",id:"how-do-i-test-purchases",level:3},{value:"Should I cache product information?",id:"should-i-cache-product-information",level:3},{value:"Migration Questions",id:"migration-questions",level:2},{value:"How do I migrate from v5 to v6?",id:"how-do-i-migrate-from-v5-to-v6",level:3},{value:"What breaking changes should I be aware of?",id:"what-breaking-changes-should-i-be-aware-of",level:3},{value:"Can I use both old and new APIs?",id:"can-i-use-both-old-and-new-apis",level:3},{value:"Troubleshooting Questions",id:"troubleshooting-questions",level:2},{value:"Why are my products not loading?",id:"why-are-my-products-not-loading",level:3},{value:"Why do purchases fail silently?",id:"why-do-purchases-fail-silently",level:3},{value:"How do I handle stuck transactions?",id:"how-do-i-handle-stuck-transactions",level:3},{value:"Performance Questions",id:"performance-questions",level:2},{value:"How can I optimize purchase flow performance?",id:"how-can-i-optimize-purchase-flow-performance",level:3},{value:"Should I keep the connection open?",id:"should-i-keep-the-connection-open",level:3},{value:"Additional Resources",id:"additional-resources",level:2},{value:"Where can I find more examples?",id:"where-can-i-find-more-examples",level:3},{value:"How do I get help?",id:"how-do-i-get-help",level:3},{value:"How can I contribute?",id:"how-can-i-contribute",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"frequently-asked-questions",children:"Frequently Asked Questions"})}),"\n",(0,s.jsx)(n.p,{children:"Common questions and answers about flutter_inapp_purchase v6.0.0, covering implementation, platform differences, best practices, and migration."}),"\n",(0,s.jsx)(n.h2,{id:"general-questions",children:"General Questions"}),"\n",(0,s.jsx)(n.h3,{id:"what-is-flutter_inapp_purchase",children:"What is flutter_inapp_purchase?"}),"\n",(0,s.jsx)(n.p,{children:"flutter_inapp_purchase is a Flutter plugin that provides a unified API for implementing in-app purchases across iOS and Android platforms. It supports:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Consumable products (coins, gems, lives)"}),"\n",(0,s.jsx)(n.li,{children:"Non-consumable products (premium features, ad removal)"}),"\n",(0,s.jsx)(n.li,{children:"Auto-renewable subscriptions"}),"\n",(0,s.jsx)(n.li,{children:"Receipt validation"}),"\n",(0,s.jsx)(n.li,{children:"Purchase restoration"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"which-platforms-are-supported",children:"Which platforms are supported?"}),"\n",(0,s.jsx)(n.p,{children:"Currently supported platforms:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"iOS"})," (12.0+) - Uses StoreKit 2 (iOS 15.0+) with fallback to StoreKit 1"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Android"})," (minSdkVersion 21) - Uses Google Play Billing Client v8"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"whats-new-in-v600",children:"What's new in v6.0.0?"}),"\n",(0,s.jsx)(n.p,{children:"Major changes in v6.0.0:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Old API (v5.x)\nawait FlutterInappPurchase.instance.requestPurchase('product_id');\n\n// New API (v6.0.0)\nawait FlutterInappPurchase.instance.requestPurchase(\n  request: RequestPurchase(\n    ios: RequestPurchaseIOS(\n      sku: 'product_id',\n      quantity: 1,\n    ),\n    android: RequestPurchaseAndroid(\n      skus: ['product_id'],\n    ),\n  ),\n  type: PurchaseType.inapp,\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Key improvements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Platform-specific request objects"}),"\n",(0,s.jsx)(n.li,{children:"Better type safety"}),"\n",(0,s.jsx)(n.li,{children:"Enhanced error handling"}),"\n",(0,s.jsx)(n.li,{children:"Improved subscription support"}),"\n",(0,s.jsx)(n.li,{children:"StoreKit 2 support for iOS"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-questions",children:"Implementation Questions"}),"\n",(0,s.jsx)(n.h3,{id:"how-do-i-get-started",children:"How do I get started?"}),"\n",(0,s.jsx)(n.p,{children:"Basic implementation steps:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// 1. Import the package\nimport 'package:flutter_inapp_purchase/flutter_inapp_purchase.dart';\nimport 'package:flutter_inapp_purchase/types.dart' as iap_types;\n\n// 2. Initialize connection\nawait FlutterInappPurchase.instance.initConnection();\n\n// 3. Set up listeners with null checks\nFlutterInappPurchase.purchaseUpdated.listen((purchase) {\n  if (purchase != null) {\n    // Handle successful purchase\n    _handlePurchaseSuccess(purchase);\n  }\n});\n\nFlutterInappPurchase.purchaseError.listen((error) {\n  if (error != null) {\n    // Handle purchase error\n    _handlePurchaseError(error);\n  }\n});\n\n// 4. Load products\nfinal products = await FlutterInappPurchase.instance.getProducts([\n  'product_id_1',\n  'product_id_2',\n]);\n\n// 5. Request purchase\nawait FlutterInappPurchase.instance.requestPurchase(\n  request: RequestPurchase(\n    ios: RequestPurchaseIOS(sku: 'product_id', quantity: 1),\n    android: RequestPurchaseAndroid(skus: ['product_id']),\n  ),\n  type: PurchaseType.inapp,\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-do-i-handle-different-product-types",children:"How do I handle different product types?"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class ProductTypeHandler {\n  // Consumable products\n  Future<void> purchaseConsumable(String productId) async {\n    await FlutterInappPurchase.instance.requestPurchase(\n      request: RequestPurchase(\n        ios: RequestPurchaseIOS(sku: productId, quantity: 1),\n        android: RequestPurchaseAndroid(skus: [productId]),\n      ),\n      type: PurchaseType.inapp,\n    );\n\n    // Handle success in purchaseUpdated listener\n  }\n\n  // Non-consumable products\n  Future<void> purchaseNonConsumable(String productId) async {\n    // Check if already owned first\n    final availablePurchases = await FlutterInappPurchase.instance.getAvailablePurchases();\n    final alreadyOwned = availablePurchases.any((purchase) => purchase.productId == productId);\n\n    if (alreadyOwned) {\n      debugPrint('Product already owned');\n      return;\n    }\n\n    await FlutterInappPurchase.instance.requestPurchase(\n      request: RequestPurchase(\n        ios: RequestPurchaseIOS(sku: productId, quantity: 1),\n        android: RequestPurchaseAndroid(skus: [productId]),\n      ),\n      type: PurchaseType.inapp,\n    );\n  }\n\n  // Subscriptions\n  Future<void> purchaseSubscription(String productId) async {\n    await FlutterInappPurchase.instance.requestPurchase(\n      request: RequestPurchase(\n        ios: RequestPurchaseIOS(sku: productId),\n        android: RequestPurchaseAndroid(skus: [productId]),\n      ),\n      type: PurchaseType.subs, // Note: Use subs type\n    );\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-do-i-restore-purchases",children:"How do I restore purchases?"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Future<void> restorePurchases() async {\n  try {\n    // Restore purchases\n    await FlutterInappPurchase.instance.restorePurchases();\n\n    // Get available purchases\n    final purchases = await FlutterInappPurchase.instance.getAvailablePurchases();\n\n    if (purchases.isNotEmpty) {\n      debugPrint('Restored ${purchases.length} purchases');\n\n      for (final purchase in purchases) {\n        // Process restored purchase\n        await _processRestoredPurchase(purchase);\n      }\n    } else {\n      debugPrint('No purchases to restore');\n    }\n  } catch (e) {\n    debugPrint('Restore failed: $e');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-do-i-validate-receipts",children:"How do I validate receipts?"}),"\n",(0,s.jsx)(n.p,{children:"Receipt validation should always be done server-side:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class ReceiptValidator {\n  // iOS Receipt Validation\n  Future<bool> validateIOSReceipt(PurchasedItem purchase) async {\n    if (purchase.transactionReceipt == null) return false;\n\n    final response = await http.post(\n      Uri.parse('https://api.yourserver.com/validate-ios'),\n      headers: {'Content-Type': 'application/json'},\n      body: json.encode({\n        'receipt': purchase.transactionReceipt,\n        'productId': purchase.productId,\n        'transactionId': purchase.transactionId,\n        'sandbox': kDebugMode,\n      }),\n    );\n\n    return response.statusCode == 200;\n  }\n\n  // Android Receipt Validation\n  Future<bool> validateAndroidReceipt(PurchasedItem purchase) async {\n    if (purchase.purchaseToken == null) return false;\n\n    final response = await http.post(\n      Uri.parse('https://api.yourserver.com/validate-android'),\n      headers: {'Content-Type': 'application/json'},\n      body: json.encode({\n        'purchaseToken': purchase.purchaseToken,\n        'productId': purchase.productId,\n        'dataAndroid': purchase.dataAndroid,\n      }),\n    );\n\n    return response.statusCode == 200;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"platform-differences",children:"Platform Differences"}),"\n",(0,s.jsx)(n.h3,{id:"what-are-the-key-differences-between-ios-and-android",children:"What are the key differences between iOS and Android?"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Feature"}),(0,s.jsx)(n.th,{children:"iOS"}),(0,s.jsx)(n.th,{children:"Android"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Product IDs"}),(0,s.jsx)(n.td,{children:"Single SKU"}),(0,s.jsx)(n.td,{children:"Array of SKUs"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Receipt Format"}),(0,s.jsx)(n.td,{children:"Base64 encoded receipt"}),(0,s.jsx)(n.td,{children:"Purchase token"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Pending Purchases"}),(0,s.jsx)(n.td,{children:"Not supported"}),(0,s.jsx)(n.td,{children:"Supported (state = 2)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Offer Codes"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"presentCodeRedemptionSheetIOS()"})}),(0,s.jsx)(n.td,{children:"External Play Store link"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Subscription Upgrades"}),(0,s.jsx)(n.td,{children:"Automatic handling"}),(0,s.jsx)(n.td,{children:"Manual implementation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Transaction Finishing"}),(0,s.jsx)(n.td,{children:"Required for all"}),(0,s.jsx)(n.td,{children:"Acknowledgment required"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Sandbox Testing"}),(0,s.jsx)(n.td,{children:"Sandbox accounts"}),(0,s.jsx)(n.td,{children:"Test accounts & reserved IDs"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"how-do-i-handle-platform-specific-features",children:"How do I handle platform-specific features?"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class PlatformSpecificHandler {\n  // iOS-specific features\n  Future<void> handleIOSFeatures() async {\n    if (!Platform.isIOS) return;\n\n    // Present offer code redemption (iOS 14+)\n    try {\n      await FlutterInappPurchase.instance.presentCodeRedemptionSheetIOS();\n      debugPrint('Offer code redemption sheet presented');\n    } catch (e) {\n      debugPrint('Failed to present offer code sheet: $e');\n    }\n\n    // Check introductory offer eligibility\n    try {\n      final eligible = await FlutterInappPurchase.instance.isEligibleForIntroOfferIOS('product_id');\n      debugPrint('Eligible for intro offer: $eligible');\n    } catch (e) {\n      debugPrint('Failed to check intro offer eligibility: $e');\n    }\n\n    // Show subscription management\n    try {\n      await FlutterInappPurchase.instance.showManageSubscriptionsIOS();\n      debugPrint('Subscription management shown');\n    } catch (e) {\n      debugPrint('Failed to show subscription management: $e');\n    }\n  }\n\n  // Android-specific features\n  Future<void> handleAndroidFeatures() async {\n    if (!Platform.isAndroid) return;\n\n    // Handle pending purchases\n    FlutterInappPurchase.purchaseUpdated.listen((purchase) {\n      if (purchase != null && purchase.purchaseStateAndroid == 2) {\n        // Purchase is pending\n        debugPrint('Purchase pending: ${purchase.productId}');\n      }\n    });\n\n    // Deep link to subscription management\n    try {\n      await FlutterInappPurchase.instance.deepLinkToSubscriptionsAndroid();\n      debugPrint('Opened Android subscription management');\n    } catch (e) {\n      debugPrint('Failed to open subscription management: $e');\n    }\n\n    // Get connection state\n    try {\n      final state = await FlutterInappPurchase.instance.getConnectionStateAndroid();\n      debugPrint('Android connection state: $state');\n    } catch (e) {\n      debugPrint('Failed to get connection state: $e');\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"do-i-need-different-product-ids-for-each-platform",children:"Do I need different product IDs for each platform?"}),"\n",(0,s.jsx)(n.p,{children:"Yes, typically you'll have different product IDs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class ProductIds {\n  static String getProductId(String baseId) {\n    if (Platform.isIOS) {\n      return 'ios_$baseId';\n    } else {\n      return 'android_$baseId';\n    }\n  }\n\n  // Or use a mapping approach\n  static const productMap = {\n    'premium': {\n      'ios': 'premium_ios',\n      'android': 'premium_android',\n    },\n    'coins_100': {\n      'ios': 'coins_100_ios',\n      'android': 'coins_100_android',\n    },\n  };\n\n  static String getMappedId(String key) {\n    final platform = Platform.isIOS ? 'ios' : 'android';\n    return productMap[key]?[platform] ?? key;\n  }\n\n  // Example from the actual project\n  static const actualProductIds = [\n    'dev.hyo.martie.10bulbs',\n    'dev.hyo.martie.30bulbs',\n  ];\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"should-i-verify-purchases-client-side-or-server-side",children:"Should I verify purchases client-side or server-side?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Always verify purchases server-side"})," for security:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// \u274c Don't do this - Client-side only\nvoid badPractice(PurchasedItem purchase) {\n  // Directly deliver content without verification\n  deliverContent(purchase.productId);\n}\n\n// \u2705 Do this - Server-side verification\nFuture<void> goodPractice(PurchasedItem purchase) async {\n  // 1. Send to server for verification\n  final isValid = await verifyOnServer(purchase);\n\n  // 2. Only deliver content if verified\n  if (isValid) {\n    await deliverContent(purchase.productId);\n    await finishTransaction(purchase);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-should-i-handle-errors",children:"How should I handle errors?"}),"\n",(0,s.jsx)(n.p,{children:"Implement comprehensive error handling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class ErrorHandler {\n  static void handlePurchaseError(PurchaseResult? error) {\n    if (error == null) return;\n\n    switch (error.responseCode) {\n      case 1: // User cancelled\n        // Don't show error for user cancellation\n        debugPrint('User cancelled purchase');\n        break;\n\n      case 2: // Network error\n        showRetryDialog('Network error. Please check your connection.');\n        break;\n\n      case 7: // Already owned\n        showMessage('You already own this item.');\n        suggestRestorePurchases();\n        break;\n\n      default:\n        showGenericError();\n        logError(error);\n    }\n  }\n\n  static void showRetryDialog(String message) {\n    // Show retry dialog implementation\n  }\n\n  static void showMessage(String message) {\n    // Show message implementation\n  }\n\n  static void suggestRestorePurchases() {\n    // Suggest restore purchases implementation\n  }\n\n  static void showGenericError() {\n    // Show generic error implementation\n  }\n\n  static void logError(PurchaseResult error) {\n    debugPrint('Purchase error: ${error.message}');\n    debugPrint('Error code: ${error.responseCode}');\n    debugPrint('Debug message: ${error.debugMessage}');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-do-i-test-purchases",children:"How do I test purchases?"}),"\n",(0,s.jsx)(n.p,{children:"Testing approach for each platform:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class PurchaseTesting {\n  // iOS Testing\n  static void setupIOSTesting() {\n    // 1. Create sandbox tester in App Store Connect\n    // 2. Sign out of production account on device\n    // 3. Don't sign into sandbox account in Settings\n    // 4. Use sandbox account when prompted during purchase\n\n    // For local testing with StoreKit configuration:\n    // 1. Create .storekit file in Xcode\n    // 2. Add test products\n    // 3. Run app with StoreKit configuration\n\n    debugPrint('iOS Testing Setup:');\n    debugPrint('- Create sandbox test account in App Store Connect');\n    debugPrint('- Products must be \"Ready to Submit\"');\n    debugPrint('- Banking and tax forms must be completed');\n  }\n\n  // Android Testing\n  static void setupAndroidTesting() {\n    // Option 1: Use test product IDs\n    final testProducts = [\n      'android.test.purchased',     // Always succeeds\n      'android.test.canceled',      // Always cancelled\n      'android.test.refunded',      // Always refunded\n      'android.test.item_unavailable', // Always unavailable\n    ];\n\n    // Option 2: Use license testers\n    // 1. Add testers in Play Console\n    // 2. Upload signed APK to internal testing\n    // 3. Download from testing track\n\n    debugPrint('Android Testing Setup:');\n    debugPrint('- Upload signed APK to Play Console');\n    debugPrint('- Add license testing accounts');\n    debugPrint('- Products must be \"Active\"');\n    debugPrint('- Test with: $testProducts');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"should-i-cache-product-information",children:"Should I cache product information?"}),"\n",(0,s.jsx)(n.p,{children:"Yes, cache products for better UX:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class ProductCache {\n  static final Map<String, IapItem> _cache = {};\n  static DateTime? _lastFetch;\n  static const cacheDuration = Duration(hours: 1);\n\n  static Future<List<IapItem>> getProducts(List<String> ids) async {\n    // Check cache validity\n    if (_lastFetch != null &&\n        DateTime.now().difference(_lastFetch!) < cacheDuration &&\n        ids.every((id) => _cache.containsKey(id))) {\n      return ids.map((id) => _cache[id]!).toList();\n    }\n\n    // Fetch fresh data\n    try {\n      final products = await FlutterInappPurchase.instance.getProducts(ids);\n\n      // Update cache\n      for (final product in products) {\n        if (product.productId != null) {\n          _cache[product.productId!] = product;\n        }\n      }\n      _lastFetch = DateTime.now();\n\n      return products;\n    } catch (e) {\n      debugPrint('Error fetching products: $e');\n      // Return cached data on error\n      return ids\n          .where((id) => _cache.containsKey(id))\n          .map((id) => _cache[id]!)\n          .toList();\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"migration-questions",children:"Migration Questions"}),"\n",(0,s.jsx)(n.h3,{id:"how-do-i-migrate-from-v5-to-v6",children:"How do I migrate from v5 to v6?"}),"\n",(0,s.jsx)(n.p,{children:"Key migration steps:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// 1. Update purchase requests\n// Old (v5.x)\nawait _iap.requestPurchase('product_id');\n\n// New (v6.0.0)\nawait _iap.requestPurchase(\n  request: RequestPurchase(\n    ios: RequestPurchaseIOS(sku: 'product_id', quantity: 1),\n    android: RequestPurchaseAndroid(skus: ['product_id']),\n  ),\n  type: PurchaseType.inapp,\n);\n\n// 2. Update subscription requests\n// Old (v5.x)\nawait _iap.requestSubscription('subscription_id');\n\n// New (v6.0.0)\nawait _iap.requestPurchase(\n  request: RequestPurchase(\n    ios: RequestPurchaseIOS(sku: 'subscription_id'),\n    android: RequestPurchaseAndroid(skus: ['subscription_id']),\n  ),\n  type: PurchaseType.subs,\n);\n\n// 3. Update method names\n// finishTransaction -> finishTransactionIOS\nawait _iap.finishTransactionIOS(purchase, isConsumable: true);\n\n// 4. Add null checks to stream listeners\nFlutterInappPurchase.purchaseUpdated.listen((purchase) {\n  if (purchase != null) {\n    // Handle purchase\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"what-breaking-changes-should-i-be-aware-of",children:"What breaking changes should I be aware of?"}),"\n",(0,s.jsx)(n.p,{children:"Major breaking changes in v6.0.0:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Request API Changed"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Now uses platform-specific request objects"}),"\n",(0,s.jsx)(n.li,{children:"Type parameter is required"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Method Renames"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"finishTransaction"})," \u2192 ",(0,s.jsx)(n.code,{children:"finishTransactionIOS"})]}),"\n",(0,s.jsx)(n.li,{children:"Some return types changed"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Error Handling"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"New error codes added"}),"\n",(0,s.jsx)(n.li,{children:"Error structure updated"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Minimum Requirements"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"iOS 12.0+ (was 10.0+)"}),"\n",(0,s.jsx)(n.li,{children:"Android minSdk 21 (was 19)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"can-i-use-both-old-and-new-apis",children:"Can I use both old and new APIs?"}),"\n",(0,s.jsx)(n.p,{children:"The old string-based API is still supported for backward compatibility:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Legacy API - still works\nawait _iap.requestPurchase('product_id');\n\n// New API - recommended\nawait _iap.requestPurchase(\n  request: RequestPurchase(\n    ios: RequestPurchaseIOS(sku: 'product_id', quantity: 1),\n    android: RequestPurchaseAndroid(skus: ['product_id']),\n  ),\n  type: PurchaseType.inapp,\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"However, it's recommended to migrate to the new API for better functionality."}),"\n",(0,s.jsx)(n.h2,{id:"troubleshooting-questions",children:"Troubleshooting Questions"}),"\n",(0,s.jsx)(n.h3,{id:"why-are-my-products-not-loading",children:"Why are my products not loading?"}),"\n",(0,s.jsx)(n.p,{children:"Common causes and solutions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class ProductLoadingDiagnostics {\n  static Future<void> diagnose() async {\n    // 1. Check connection\n    try {\n      await FlutterInappPurchase.instance.initConnection();\n      debugPrint('\u2713 Connection established');\n    } catch (e) {\n      debugPrint('\u2717 Connection failed: $e');\n      return;\n    }\n\n    // 2. Verify product IDs\n    final testIds = ['your_product_id'];\n    debugPrint('Testing product IDs: $testIds');\n\n    // 3. Check platform-specific issues\n    if (Platform.isIOS) {\n      debugPrint('iOS Checklist:');\n      debugPrint('- Products \"Ready to Submit\" in App Store Connect');\n      debugPrint('- Banking/tax forms completed');\n      debugPrint('- Bundle ID matches');\n      debugPrint('- Using sandbox account');\n    } else {\n      debugPrint('Android Checklist:');\n      debugPrint('- Products active in Play Console');\n      debugPrint('- App published (at least internal testing)');\n      debugPrint('- Signed APK/AAB uploaded');\n      debugPrint('- Tester account added');\n    }\n\n    // 4. Try loading products\n    try {\n      final products = await FlutterInappPurchase.instance.getProducts(testIds);\n      debugPrint('\u2713 Loaded ${products.length} products');\n\n      for (final product in products) {\n        debugPrint('Product: ${product.productId} - ${product.title}');\n        debugPrint('Price: ${product.localizedPrice}');\n      }\n    } catch (e) {\n      debugPrint('\u2717 Product loading failed: $e');\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"why-do-purchases-fail-silently",children:"Why do purchases fail silently?"}),"\n",(0,s.jsx)(n.p,{children:"Ensure you're listening to both streams:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// \u274c Common mistake - only listening to one stream\nFlutterInappPurchase.purchaseUpdated.listen((purchase) {\n  // Only handles success\n});\n\n// \u2705 Correct approach - listen to both streams\nFlutterInappPurchase.purchaseUpdated.listen((purchase) {\n  // Handle successful purchases\n  if (purchase != null) {\n    processPurchase(purchase);\n  }\n});\n\nFlutterInappPurchase.purchaseError.listen((error) {\n  // Handle purchase errors\n  if (error != null) {\n    handleError(error);\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"how-do-i-handle-stuck-transactions",children:"How do I handle stuck transactions?"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Future<void> clearStuckTransactions() async {\n  try {\n    // Get all available purchases\n    final purchases = await FlutterInappPurchase.instance.getAvailablePurchases();\n\n    if (purchases.isNotEmpty) {\n      for (final purchase in purchases) {\n        try {\n          // Finish the transaction based on platform\n          if (Platform.isAndroid && purchase.purchaseToken != null) {\n            await FlutterInappPurchase.instance.consumePurchaseAndroid(\n              purchaseToken: purchase.purchaseToken!,\n            );\n          } else if (Platform.isIOS) {\n            await FlutterInappPurchase.instance.finishTransactionIOS(\n              purchase,\n              isConsumable: true,\n            );\n          }\n          debugPrint('Cleared transaction: ${purchase.transactionId}');\n        } catch (e) {\n          debugPrint('Failed to clear transaction: $e');\n        }\n      }\n    }\n  } catch (e) {\n    debugPrint('Failed to get stuck transactions: $e');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"performance-questions",children:"Performance Questions"}),"\n",(0,s.jsx)(n.h3,{id:"how-can-i-optimize-purchase-flow-performance",children:"How can I optimize purchase flow performance?"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class PerformanceOptimization {\n  // 1. Preload products\n  static Future<void> preloadProducts() async {\n    // Load products early in app lifecycle\n    final productIds = ['product1', 'product2', 'product3'];\n    await ProductCache.getProducts(productIds);\n  }\n\n  // 2. Prepare purchase flow\n  static Future<void> preparePurchaseFlow() async {\n    // Initialize connection early\n    await FlutterInappPurchase.instance.initConnection();\n\n    // Set up listeners before user interaction\n    setupPurchaseListeners();\n  }\n\n  static void setupPurchaseListeners() {\n    FlutterInappPurchase.purchaseUpdated.listen((purchase) {\n      if (purchase != null) {\n        // Process purchase immediately\n        _processPurchaseImmediately(purchase);\n      }\n    });\n\n    FlutterInappPurchase.purchaseError.listen((error) {\n      if (error != null) {\n        // Handle error immediately\n        _handleErrorImmediately(error);\n      }\n    });\n  }\n\n  static void _processPurchaseImmediately(PurchasedItem purchase) {\n    // Implementation for immediate purchase processing\n  }\n\n  static void _handleErrorImmediately(PurchaseResult error) {\n    // Implementation for immediate error handling\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"should-i-keep-the-connection-open",children:"Should I keep the connection open?"}),"\n",(0,s.jsx)(n.p,{children:"Best practices for connection management:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class ConnectionManagement {\n  // Initialize on app start\n  static Future<void> initializeOnAppStart() async {\n    try {\n      await FlutterInappPurchase.instance.initConnection();\n      debugPrint('IAP connection initialized');\n    } catch (e) {\n      debugPrint('Failed to initialize IAP connection: $e');\n    }\n  }\n\n  // Keep connection alive during purchase flows\n  static void maintainConnection() {\n    // Don't close connection between purchases\n    // Only close when app is terminating\n  }\n\n  // Clean up on app termination\n  static Future<void> cleanup() async {\n    try {\n      await FlutterInappPurchase.instance.finalize();\n      debugPrint('IAP connection closed');\n    } catch (e) {\n      debugPrint('Failed to close IAP connection: $e');\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,s.jsx)(n.h3,{id:"where-can-i-find-more-examples",children:"Where can I find more examples?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/hyochan/flutter_inapp_purchase/tree/main/example",children:"GitHub Repository Examples"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/api/flutter-inapp-purchase",children:"API Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/guides/troubleshooting",children:"Troubleshooting Guide"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"how-do-i-get-help",children:"How do I get help?"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Check the ",(0,s.jsx)(n.a,{href:"/docs/guides/troubleshooting",children:"Troubleshooting Guide"})]}),"\n",(0,s.jsxs)(n.li,{children:["Search ",(0,s.jsx)(n.a,{href:"https://github.com/hyochan/flutter_inapp_purchase/issues",children:"GitHub Issues"})]}),"\n",(0,s.jsxs)(n.li,{children:["Post on ",(0,s.jsx)(n.a,{href:"https://stackoverflow.com/questions/tagged/flutter-inapp-purchase",children:"Stack Overflow"})," with tag ",(0,s.jsx)(n.code,{children:"flutter-inapp-purchase"})]}),"\n",(0,s.jsxs)(n.li,{children:["Join ",(0,s.jsx)(n.a,{href:"https://flutter.dev/community",children:"Flutter Community"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"how-can-i-contribute",children:"How can I contribute?"}),"\n",(0,s.jsxs)(n.p,{children:["Contributions are welcome! See the ",(0,s.jsx)(n.a,{href:"https://github.com/hyochan/flutter_inapp_purchase/blob/main/CONTRIBUTING.md",children:"Contributing Guidelines"})," for:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Bug reports"}),"\n",(0,s.jsx)(n.li,{children:"Feature requests"}),"\n",(0,s.jsx)(n.li,{children:"Pull requests"}),"\n",(0,s.jsx)(n.li,{children:"Documentation improvements"}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);