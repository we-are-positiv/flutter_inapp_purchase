"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[5694],{6764:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"guides/products","title":"Working with Products","description":"This guide covers how to implement and manage one-time purchase products (consumables and non-consumables).","source":"@site/docs/guides/products.md","sourceDirName":"guides","slug":"/guides/products","permalink":"/docs/guides/products","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/docs/guides/products.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1}}');var s=r(4848),t=r(8453);const a={sidebar_position:1},c="Working with Products",o={},d=[{value:"Product Types",id:"product-types",level:2},{value:"Consumable Products",id:"consumable-products",level:3},{value:"Non-Consumable Products",id:"non-consumable-products",level:3},{value:"Loading Products",id:"loading-products",level:2},{value:"Basic Product Loading",id:"basic-product-loading",level:3},{value:"Product Information",id:"product-information",level:3},{value:"Implementing Purchases",id:"implementing-purchases",level:2},{value:"Purchase Flow",id:"purchase-flow",level:3},{value:"Completing Transactions",id:"completing-transactions",level:3},{value:"iOS",id:"ios",level:4},{value:"Android",id:"android",level:4},{value:"Purchase Verification",id:"purchase-verification",level:2},{value:"Client-Side Validation",id:"client-side-validation",level:3},{value:"Server-Side Validation",id:"server-side-validation",level:3},{value:"Handling Different Product Types",id:"handling-different-product-types",level:2},{value:"Consumable Products",id:"consumable-products-1",level:3},{value:"Non-Consumable Products",id:"non-consumable-products-1",level:3},{value:"Restoring Purchases",id:"restoring-purchases",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Product Loading",id:"1-product-loading",level:3},{value:"2. Purchase Flow",id:"2-purchase-flow",level:3},{value:"3. Error Handling",id:"3-error-handling",level:3},{value:"4. Testing",id:"4-testing",level:3},{value:"Common Issues",id:"common-issues",level:2},{value:"Products Not Loading",id:"products-not-loading",level:3},{value:"Purchase Not Completing",id:"purchase-not-completing",level:3},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"working-with-products",children:"Working with Products"})}),"\n",(0,s.jsx)(n.p,{children:"This guide covers how to implement and manage one-time purchase products (consumables and non-consumables)."}),"\n",(0,s.jsx)(n.h2,{id:"product-types",children:"Product Types"}),"\n",(0,s.jsx)(n.h3,{id:"consumable-products",children:"Consumable Products"}),"\n",(0,s.jsx)(n.p,{children:"Products that can be purchased multiple times:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Virtual currency (coins, gems)"}),"\n",(0,s.jsx)(n.li,{children:"Power-ups or boosters"}),"\n",(0,s.jsx)(n.li,{children:"Extra lives or hints"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"non-consumable-products",children:"Non-Consumable Products"}),"\n",(0,s.jsx)(n.p,{children:"Products purchased once and owned forever:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Remove ads"}),"\n",(0,s.jsx)(n.li,{children:"Unlock premium features"}),"\n",(0,s.jsx)(n.li,{children:"Expansion packs"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"loading-products",children:"Loading Products"}),"\n",(0,s.jsx)(n.h3,{id:"basic-product-loading",children:"Basic Product Loading"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Define your product IDs\nfinal List<String> productIds = [\n  'com.example.coins_100',\n  'com.example.coins_500',\n  'com.example.remove_ads',\n];\n\n// Load products\nFuture<void> loadProducts() async {\n  try {\n    List<IapItem> products = await FlutterInappPurchase.instance\n        .requestProducts(skus: productIds, type: 'inapp');\n\n    for (var product in products) {\n      print('Product: ${product.productId}');\n      print('Title: ${product.title}');\n      print('Price: ${product.localizedPrice}');\n    }\n  } catch (e) {\n    print('Failed to load products: $e');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"product-information",children:"Product Information"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"IapItem"})," class contains:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class IapItem {\n  String? productId;          // Unique identifier\n  String? price;              // Raw price value\n  String? currency;           // Currency code\n  String? localizedPrice;     // Formatted price string\n  String? title;              // Product name\n  String? description;        // Product description\n\n  // iOS specific\n  String? introductoryPrice;\n  String? subscriptionPeriodNumberIOS;\n\n  // Android specific\n  String? signatureAndroid;\n  String? originalJsonAndroid;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"implementing-purchases",children:"Implementing Purchases"}),"\n",(0,s.jsx)(n.h3,{id:"purchase-flow",children:"Purchase Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class ProductStore {\n  StreamSubscription? _purchaseUpdatedSubscription;\n\n  void initializePurchaseListener() {\n    _purchaseUpdatedSubscription = FlutterInappPurchase\n        .purchaseUpdated.listen((productItem) {\n      if (productItem != null) {\n        handlePurchaseUpdate(productItem);\n      }\n    });\n  }\n\n  Future<void> purchaseProduct(String productId) async {\n    try {\n      await FlutterInappPurchase.instance.requestPurchase(productId);\n      // Purchase result will be delivered via stream\n    } catch (e) {\n      handlePurchaseError(e);\n    }\n  }\n\n  void handlePurchaseUpdate(PurchasedItem item) async {\n    // 1. Verify the purchase\n    bool isValid = await verifyPurchase(item);\n\n    if (isValid) {\n      // 2. Deliver the product\n      await deliverProduct(item);\n\n      // 3. Complete the transaction\n      await completePurchase(item);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"completing-transactions",children:"Completing Transactions"}),"\n",(0,s.jsx)(n.h4,{id:"ios",children:"iOS"}),"\n",(0,s.jsx)(n.p,{children:"All purchases must be finished:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"await FlutterInappPurchase.instance.finishTransaction(item);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"android",children:"Android"}),"\n",(0,s.jsx)(n.p,{children:"Consumable products must be consumed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// For consumable products\nawait FlutterInappPurchase.instance.consumePurchase(\n  purchaseToken: item.purchaseToken!,\n);\n\n// For non-consumable products\nawait FlutterInappPurchase.instance.acknowledgePurchase(\n  purchaseToken: item.purchaseToken!,\n);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"purchase-verification",children:"Purchase Verification"}),"\n",(0,s.jsx)(n.h3,{id:"client-side-validation",children:"Client-Side Validation"}),"\n",(0,s.jsx)(n.p,{children:"Basic validation before server verification:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"bool validatePurchaseLocally(PurchasedItem item) {\n  // Check required fields\n  if (item.productId == null || item.transactionId == null) {\n    return false;\n  }\n\n  // Check purchase state (Android)\n  if (Platform.isAndroid) {\n    // 0 = Purchased, 1 = Pending\n    if (item.purchaseStateAndroid != 0) {\n      return false;\n    }\n  }\n\n  // Check transaction date is reasonable\n  int now = DateTime.now().millisecondsSinceEpoch;\n  int purchaseTime = item.transactionDate ?? 0;\n  if (purchaseTime > now || purchaseTime < now - 86400000) { // 24 hours\n    return false;\n  }\n\n  return true;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"server-side-validation",children:"Server-Side Validation"}),"\n",(0,s.jsx)(n.p,{children:"Always verify purchases on your server:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Future<bool> verifyPurchase(PurchasedItem item) async {\n  // Get receipt data\n  String? receipt;\n  if (Platform.isIOS) {\n    receipt = await FlutterInappPurchase.instance.getReceiptData();\n  } else {\n    receipt = item.purchaseToken;\n  }\n\n  // Send to your server\n  final response = await http.post(\n    Uri.parse('https://api.example.com/verify-purchase'),\n    body: {\n      'platform': Platform.isIOS ? 'ios' : 'android',\n      'productId': item.productId,\n      'receipt': receipt,\n      'transactionId': item.transactionId,\n    },\n  );\n\n  return response.statusCode == 200;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"handling-different-product-types",children:"Handling Different Product Types"}),"\n",(0,s.jsx)(n.h3,{id:"consumable-products-1",children:"Consumable Products"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class ConsumableManager {\n  // Track consumable inventory\n  Map<String, int> inventory = {};\n\n  Future<void> handleConsumablePurchase(PurchasedItem item) async {\n    // Add to inventory\n    String productId = item.productId!;\n    int amount = getProductAmount(productId);\n    inventory[productId] = (inventory[productId] ?? 0) + amount;\n\n    // Save to persistent storage\n    await saveInventory();\n\n    // Consume the purchase (Android)\n    if (Platform.isAndroid) {\n      await FlutterInappPurchase.instance.consumePurchase(\n        purchaseToken: item.purchaseToken!,\n      );\n    }\n\n    // Finish transaction (iOS)\n    if (Platform.isIOS) {\n      await FlutterInappPurchase.instance.finishTransaction(item);\n    }\n  }\n\n  int getProductAmount(String productId) {\n    // Define your product amounts\n    switch (productId) {\n      case 'coins_100': return 100;\n      case 'coins_500': return 500;\n      default: return 0;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"non-consumable-products-1",children:"Non-Consumable Products"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class NonConsumableManager {\n  Set<String> unlockedFeatures = {};\n\n  Future<void> handleNonConsumablePurchase(PurchasedItem item) async {\n    // Unlock the feature\n    unlockedFeatures.add(item.productId!);\n\n    // Save to persistent storage\n    await saveUnlockedFeatures();\n\n    // Acknowledge purchase (Android)\n    if (Platform.isAndroid && item.isAcknowledgedAndroid == false) {\n      await FlutterInappPurchase.instance.acknowledgePurchase(\n        purchaseToken: item.purchaseToken!,\n      );\n    }\n\n    // Finish transaction (iOS)\n    if (Platform.isIOS) {\n      await FlutterInappPurchase.instance.finishTransaction(item);\n    }\n  }\n\n  bool isFeatureUnlocked(String productId) {\n    return unlockedFeatures.contains(productId);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"restoring-purchases",children:"Restoring Purchases"}),"\n",(0,s.jsx)(n.p,{children:"Always provide a way to restore non-consumable purchases:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"Future<void> restorePurchases() async {\n  try {\n    List<PurchasedItem>? purchases = await FlutterInappPurchase\n        .instance.getAvailablePurchases();\n\n    if (purchases != null) {\n      for (var purchase in purchases) {\n        // Re-deliver non-consumable products\n        if (isNonConsumable(purchase.productId)) {\n          await deliverProduct(purchase);\n        }\n      }\n    }\n\n    showMessage('Purchases restored successfully');\n  } catch (e) {\n    showError('Failed to restore purchases: $e');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-product-loading",children:"1. Product Loading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cache product information to reduce API calls"}),"\n",(0,s.jsx)(n.li,{children:"Handle network failures gracefully"}),"\n",(0,s.jsx)(n.li,{children:"Show loading states while fetching products"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-purchase-flow",children:"2. Purchase Flow"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Disable purchase buttons during transaction"}),"\n",(0,s.jsx)(n.li,{children:"Show clear purchase confirmation dialogs"}),"\n",(0,s.jsx)(n.li,{children:"Handle pending purchases (especially on Android)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-error-handling",children:"3. Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"void handlePurchaseError(dynamic error) {\n  if (error.code == 'E_USER_CANCELLED') {\n    // User cancelled - no need to show error\n    return;\n  }\n\n  String message = 'Purchase failed';\n  switch (error.code) {\n    case 'E_NETWORK':\n      message = 'Network error. Please try again.';\n      break;\n    case 'E_ITEM_UNAVAILABLE':\n      message = 'This item is not available.';\n      break;\n    case 'E_SERVICE_ERROR':\n      message = 'Store service error. Please try later.';\n      break;\n    default:\n      message = 'Purchase failed: ${error.message}';\n  }\n\n  showError(message);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-testing",children:"4. Testing"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Test with different product types"}),"\n",(0,s.jsx)(n.li,{children:"Test purchase restoration"}),"\n",(0,s.jsx)(n.li,{children:"Test network failures"}),"\n",(0,s.jsx)(n.li,{children:"Test with multiple test accounts"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-issues",children:"Common Issues"}),"\n",(0,s.jsx)(n.h3,{id:"products-not-loading",children:"Products Not Loading"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Verify product IDs match exactly"}),"\n",(0,s.jsx)(n.li,{children:"Check products are active in store console"}),"\n",(0,s.jsx)(n.li,{children:"Ensure app is properly configured"}),"\n",(0,s.jsx)(n.li,{children:"Wait for product propagation (can take 24 hours)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"purchase-not-completing",children:"Purchase Not Completing"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Check internet connection"}),"\n",(0,s.jsx)(n.li,{children:"Verify transaction finishing logic"}),"\n",(0,s.jsx)(n.li,{children:"Handle pending purchases properly"}),"\n",(0,s.jsx)(n.li,{children:"Check for acknowledgment (Android)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./subscriptions",children:"Subscriptions Guide"})," - Implementing auto-renewable subscriptions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./receipt-validation",children:"Receipt Validation"})," - Verifying purchases securely"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./error-handling",children:"Error Handling"})," - Comprehensive error management"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var i=r(6540);const s={},t=i.createContext(s);function a(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);