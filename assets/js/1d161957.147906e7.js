"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[8723],{6497:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>t,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"api/methods/get-available-purchases","title":"getAvailablePurchases","description":"Retrieves all non-consumed purchases made by the user.","source":"@site/docs/api/methods/get-available-purchases.md","sourceDirName":"api/methods","slug":"/api/methods/get-available-purchases","permalink":"/docs/api/methods/get-available-purchases","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/docs/api/methods/get-available-purchases.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"getAvailablePurchases"}}');var r=s(4848),i=s(8453);const t={sidebar_position:7,title:"getAvailablePurchases"},c="getAvailablePurchases()",l={},o=[{value:"Overview",id:"overview",level:2},{value:"Signatures",id:"signatures",level:2},{value:"expo-iap Compatible",id:"expo-iap-compatible",level:3},{value:"Legacy Method",id:"legacy-method",level:3},{value:"Returns",id:"returns",level:2},{value:"Platform Behavior",id:"platform-behavior",level:2},{value:"iOS",id:"ios",level:3},{value:"Android",id:"android",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Restore Purchases",id:"restore-purchases",level:3},{value:"Check Subscription Status",id:"check-subscription-status",level:3},{value:"Handle Pending Transactions",id:"handle-pending-transactions",level:3},{value:"Filter Purchase Types",id:"filter-purchase-types",level:3},{value:"Complete Implementation",id:"complete-implementation",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Common Use Cases",id:"common-use-cases",level:2},{value:"Related Methods",id:"related-methods",level:2},{value:"Platform Notes",id:"platform-notes",level:2},{value:"iOS",id:"ios-1",level:3},{value:"Android",id:"android-1",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"getavailablepurchases",children:"getAvailablePurchases()"})}),"\n",(0,r.jsx)(n.p,{children:"Retrieves all non-consumed purchases made by the user."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"getAvailablePurchases()"})," method returns a list of purchases that haven't been consumed or finished. This is useful for restoring purchases, checking subscription status, and handling incomplete transactions."]}),"\n",(0,r.jsx)(n.h2,{id:"signatures",children:"Signatures"}),"\n",(0,r.jsx)(n.h3,{id:"expo-iap-compatible",children:"expo-iap Compatible"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"Future<List<Purchase>> getAvailablePurchases()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"legacy-method",children:"Legacy Method"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"Future<List<PurchasedItem>?> getAvailableItemsIOS()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,r.jsx)(n.p,{children:"A list of active purchases including:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Non-consumable items"}),"\n",(0,r.jsx)(n.li,{children:"Active subscriptions"}),"\n",(0,r.jsx)(n.li,{children:"Unfinished transactions"}),"\n",(0,r.jsx)(n.li,{children:"Purchases awaiting acknowledgment (Android)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"platform-behavior",children:"Platform Behavior"}),"\n",(0,r.jsx)(n.h3,{id:"ios",children:"iOS"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Returns all transactions in the payment queue"}),"\n",(0,r.jsx)(n.li,{children:"Includes restored purchases"}),"\n",(0,r.jsx)(n.li,{children:"Shows both finished and unfinished transactions"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"android",children:"Android"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Returns purchases from Google Play"}),"\n",(0,r.jsx)(n.li,{children:"Includes both in-app products and subscriptions"}),"\n",(0,r.jsx)(n.li,{children:"Only shows purchases that haven't been consumed"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Get all available purchases\nfinal purchases = await FlutterInappPurchase.instance.getAvailablePurchases();\n\nfor (var purchase in purchases) {\n  print('Active purchase: ${purchase.productId}');\n  print('Transaction ID: ${purchase.transactionId}');\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"restore-purchases",children:"Restore Purchases"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class PurchaseRestorer {\n  final _iap = FlutterInappPurchase.instance;\n  \n  Future<void> restorePurchases() async {\n    try {\n      // Show loading indicator\n      showLoading(true);\n      \n      // Get all available purchases\n      final purchases = await _iap.getAvailablePurchases();\n      \n      if (purchases.isEmpty) {\n        showMessage('No purchases to restore');\n        return;\n      }\n      \n      // Process each purchase\n      for (var purchase in purchases) {\n        await _processPurchase(purchase);\n      }\n      \n      showMessage('Restored ${purchases.length} purchases');\n      \n    } catch (e) {\n      showError('Failed to restore purchases: $e');\n    } finally {\n      showLoading(false);\n    }\n  }\n  \n  Future<void> _processPurchase(Purchase purchase) async {\n    // Verify the purchase\n    if (await _verifyPurchase(purchase)) {\n      // Unlock content\n      await _unlockContent(purchase.productId);\n      \n      // Finish transaction if needed\n      if (_shouldFinishTransaction(purchase)) {\n        await _iap.finishTransaction(purchase);\n      }\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"check-subscription-status",children:"Check Subscription Status"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class SubscriptionChecker {\n  final _subscriptionIds = [\n    'com.example.monthly',\n    'com.example.yearly',\n    'com.example.premium',\n  ];\n  \n  Future<SubscriptionStatus> checkSubscriptionStatus() async {\n    try {\n      final purchases = await FlutterInappPurchase.instance.getAvailablePurchases();\n      \n      // Find active subscriptions\n      final activeSubscriptions = purchases.where((p) => \n        _subscriptionIds.contains(p.productId)\n      ).toList();\n      \n      if (activeSubscriptions.isEmpty) {\n        return SubscriptionStatus(\n          isActive: false,\n          activeProduct: null,\n        );\n      }\n      \n      // Get the most recent subscription\n      activeSubscriptions.sort((a, b) => \n        (b.transactionDate ?? DateTime(1970))\n            .compareTo(a.transactionDate ?? DateTime(1970))\n      );\n      \n      final latestSubscription = activeSubscriptions.first;\n      \n      return SubscriptionStatus(\n        isActive: true,\n        activeProduct: latestSubscription.productId,\n        expirationDate: _calculateExpirationDate(latestSubscription),\n      );\n      \n    } catch (e) {\n      print('Error checking subscription: $e');\n      return SubscriptionStatus(isActive: false, activeProduct: null);\n    }\n  }\n  \n  DateTime? _calculateExpirationDate(Purchase purchase) {\n    // Implementation depends on your subscription periods\n    // This is a simplified example\n    if (purchase.productId == 'com.example.monthly') {\n      return purchase.transactionDate?.add(Duration(days: 30));\n    } else if (purchase.productId == 'com.example.yearly') {\n      return purchase.transactionDate?.add(Duration(days: 365));\n    }\n    return null;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"handle-pending-transactions",children:"Handle Pending Transactions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class PendingTransactionHandler {\n  final _iap = FlutterInappPurchase.instance;\n  \n  Future<void> processPendingTransactions() async {\n    final purchases = await _iap.getAvailablePurchases();\n    \n    for (var purchase in purchases) {\n      if (_isPending(purchase)) {\n        print('Found pending transaction: ${purchase.productId}');\n        \n        // Try to complete the transaction\n        await _completePendingTransaction(purchase);\n      }\n    }\n  }\n  \n  bool _isPending(Purchase purchase) {\n    // Check platform-specific pending states\n    if (Platform.isAndroid) {\n      return purchase.purchaseStateAndroid == 'pending';\n    } else if (Platform.isIOS) {\n      // iOS transactions in queue are pending\n      return true;\n    }\n    return false;\n  }\n  \n  Future<void> _completePendingTransaction(Purchase purchase) async {\n    try {\n      // Verify with backend\n      final isValid = await _verifyWithBackend(purchase);\n      \n      if (isValid) {\n        // Deliver content\n        await _deliverContent(purchase.productId);\n        \n        // Finish transaction\n        await _iap.finishTransaction(purchase);\n      }\n    } catch (e) {\n      print('Error completing pending transaction: $e');\n      // Transaction remains pending for retry\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"filter-purchase-types",children:"Filter Purchase Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class PurchaseFilter {\n  List<Purchase> filterConsumables(List<Purchase> purchases) {\n    const consumableIds = ['coins_100', 'coins_500', 'gems_pack'];\n    return purchases.where((p) => consumableIds.contains(p.productId)).toList();\n  }\n  \n  List<Purchase> filterNonConsumables(List<Purchase> purchases) {\n    const nonConsumableIds = ['remove_ads', 'unlock_pro', 'theme_pack'];\n    return purchases.where((p) => nonConsumableIds.contains(p.productId)).toList();\n  }\n  \n  List<Purchase> filterSubscriptions(List<Purchase> purchases) {\n    const subscriptionIds = ['monthly_sub', 'yearly_sub'];\n    return purchases.where((p) => subscriptionIds.contains(p.productId)).toList();\n  }\n  \n  List<Purchase> filterUnacknowledged(List<Purchase> purchases) {\n    if (Platform.isAndroid) {\n      return purchases.where((p) => p.isAcknowledgedAndroid == false).toList();\n    }\n    return [];\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"complete-implementation",children:"Complete Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class PurchaseManager {\n  final _iap = FlutterInappPurchase.instance;\n  final _ownedProducts = <String>{};\n  \n  Future<void> syncPurchases() async {\n    try {\n      // Get all available purchases\n      final purchases = await _iap.getAvailablePurchases();\n      \n      // Clear current state\n      _ownedProducts.clear();\n      \n      // Process each purchase\n      for (var purchase in purchases) {\n        // Add to owned products\n        _ownedProducts.add(purchase.productId);\n        \n        // Handle based on platform\n        if (Platform.isAndroid && !purchase.isAcknowledgedAndroid!) {\n          // Acknowledge Android purchase\n          await _acknowledgeAndroidPurchase(purchase);\n        }\n        \n        // Unlock content if not already unlocked\n        if (!await _isContentUnlocked(purchase.productId)) {\n          await _unlockContent(purchase.productId);\n        }\n      }\n      \n      print('Synced ${_ownedProducts.length} purchases');\n      \n    } catch (e) {\n      print('Error syncing purchases: $e');\n    }\n  }\n  \n  bool isProductOwned(String productId) {\n    return _ownedProducts.contains(productId);\n  }\n  \n  Future<void> _acknowledgeAndroidPurchase(Purchase purchase) async {\n    if (purchase.purchaseToken != null) {\n      await _iap.acknowledgePurchaseAndroid(\n        purchaseToken: purchase.purchaseToken!,\n      );\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cache Results"}),": Don't call this method too frequently"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Verify Purchases"}),": Always verify purchases with your backend"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle Duplicates"}),": Check for duplicate transactions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Process All"}),": Process all available purchases on app launch"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Recovery"}),": Implement retry logic for failed processing"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"common-use-cases",children:"Common Use Cases"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Restore Purchases"}),": After app reinstall or device change"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Subscription Check"}),": Verify active subscription status"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pending Transactions"}),": Complete interrupted purchases"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Content Sync"}),": Ensure all purchased content is unlocked"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Receipt Validation"}),": Get receipts for server validation"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-methods",children:"Related Methods"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getPurchaseHistory()"})," - Gets historical purchases (Android only)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/api/methods/finish-transaction",children:(0,r.jsx)(n.code,{children:"finishTransaction()"})})," - Completes transactions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"restorePurchases()"})," - iOS-specific restore method"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"platform-notes",children:"Platform Notes"}),"\n",(0,r.jsx)(n.h3,{id:"ios-1",children:"iOS"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Includes all non-finished transactions"}),"\n",(0,r.jsx)(n.li,{children:"May include very old transactions if not finished"}),"\n",(0,r.jsx)(n.li,{children:"Restored purchases appear here"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"android-1",children:"Android"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Only includes purchases from current Google account"}),"\n",(0,r.jsx)(n.li,{children:"Consumed items don't appear"}),"\n",(0,r.jsx)(n.li,{children:"Requires BILLING permission"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var a=s(6540);const r={},i=a.createContext(r);function t(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);