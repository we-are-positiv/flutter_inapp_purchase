"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[775],{5339:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"guides/lifecycle","title":"Lifecycle","description":"For complete understanding of the in-app purchase lifecycle, flow diagrams, and state management, please visit:","source":"@site/versioned_docs/version-6.3/guides/lifecycle.md","sourceDirName":"guides","slug":"/guides/lifecycle","permalink":"/docs/6.3/guides/lifecycle","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/versioned_docs/version-6.3/guides/lifecycle.md","tags":[],"version":"6.3","sidebarPosition":7,"frontMatter":{"sidebar_position":7,"title":"Lifecycle"},"sidebar":"docsSidebar","previous":{"title":"Purchases","permalink":"/docs/6.3/guides/purchases"},"next":{"title":"Offer Code Redemption","permalink":"/docs/6.3/guides/offer-code-redemption"}}');var r=s(4848),i=s(8453);const a={sidebar_position:7,title:"Lifecycle"},c="Lifecycle",o={},l=[{value:"Lifecycle Overview",id:"lifecycle-overview",level:2},{value:"Connection Management with useIAP",id:"connection-management-with-useiap",level:2},{value:"Automatic Connection",id:"automatic-connection",level:3},{value:"Connection States",id:"connection-states",level:3},{value:"Component Lifecycle Integration",id:"component-lifecycle-integration",level:2},{value:"Class Components",id:"class-components",level:3},{value:"Functional Components",id:"functional-components",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"\u2705 Do:",id:"-do",level:3},{value:"\u274c Don&#39;t:",id:"-dont",level:3},{value:"Purchase Flow Best Practices",id:"purchase-flow-best-practices",level:2},{value:"Receipt Validation and Security",id:"receipt-validation-and-security",level:3},{value:"Purchase State Management",id:"purchase-state-management",level:3},{value:"Error Handling and User Experience",id:"error-handling-and-user-experience",level:2},{value:"Comprehensive Error Handling",id:"comprehensive-error-handling",level:3},{value:"Testing and Development",id:"testing-and-development",level:2},{value:"Development Environment Setup",id:"development-environment-setup",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:2},{value:"Transaction Management Issues",id:"transaction-management-issues",level:3},{value:"Security Issues",id:"security-issues",level:3},{value:"Development and Testing Issues",id:"development-and-testing-issues",level:3},{value:"App Lifecycle Issues",id:"app-lifecycle-issues",level:3},{value:"Connection Management Issues",id:"connection-management-issues",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"lifecycle",children:"Lifecycle"})}),"\n",(0,r.jsx)(n.p,{children:"For complete understanding of the in-app purchase lifecycle, flow diagrams, and state management, please visit:"}),"\n",(0,r.jsxs)(n.p,{children:["\ud83d\udc49 ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://openiap.dev/docs/lifecycle",children:"Lifecycle Documentation - openiap.dev"})})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://openiap.dev/purchase-flow.png",alt:"Purchase Flow"})}),"\n",(0,r.jsx)(n.p,{children:"The Open IAP specification provides detailed documentation on:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Complete purchase flow"}),"\n",(0,r.jsx)(n.li,{children:"State transitions and management"}),"\n",(0,r.jsx)(n.li,{children:"Connection lifecycle"}),"\n",(0,r.jsx)(n.li,{children:"Error recovery patterns"}),"\n",(0,r.jsx)(n.li,{children:"Platform-specific considerations"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"lifecycle-overview",children:"Lifecycle Overview"}),"\n",(0,r.jsx)(n.p,{children:"The in-app purchase lifecycle consists of several key phases:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Store Connection"})," - Establishing connection with platform stores"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Product Loading"})," - Fetching available products and pricing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purchase Initiation"})," - User-triggered purchase requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transaction Processing"})," - Platform-handled payment flow"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purchase Completion"})," - Successful transaction receipt"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Content Delivery"})," - Providing purchased content to user"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transaction Finalization"})," - Consuming/acknowledging purchases"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each phase has its own requirements and potential failure modes that need proper handling."}),"\n",(0,r.jsx)(n.h2,{id:"connection-management-with-useiap",children:"Connection Management with useIAP"}),"\n",(0,r.jsx)(n.h3,{id:"automatic-connection",children:"Automatic Connection"}),"\n",(0,r.jsxs)(n.p,{children:["The flutter_inapp_purchase plugin manages connections automatically through the ",(0,r.jsx)(n.code,{children:"IapProvider"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:flutter/material.dart';\nimport 'package:flutter_inapp_purchase/flutter_inapp_purchase.dart';\n\nclass IapProviderWidget extends StatefulWidget {\n  final Widget child;\n\n  const IapProviderWidget({required this.child, Key? key}) : super(key: key);\n\n  @override\n  State<IapProviderWidget> createState() => _IapProviderWidgetState();\n}\n\nclass _IapProviderWidgetState extends State<IapProviderWidget> {\n  final FlutterInappPurchase _iap = FlutterInappPurchase.instance;\n\n  bool _connected = false;\n  bool _loading = false;\n  String? _error;\n\n  @override\n  void initState() {\n    super.initState();\n    // Automatically initialize connection when provider is created\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      _initConnection();\n    });\n  }\n\n  Future<void> _initConnection() async {\n    setState(() {\n      _loading = true;\n      _error = null;\n    });\n\n    try {\n      await _iap.initConnection();\n\n      // Set up purchase listeners\n      _setupPurchaseListeners();\n\n      setState(() {\n        _connected = true;\n        _loading = false;\n      });\n    } catch (e) {\n      setState(() {\n        _error = e.toString();\n        _loading = false;\n        _connected = false;\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _endConnection();\n    super.dispose();\n  }\n\n  Future<void> _endConnection() async {\n    try {\n      await _iap.finalize();\n      setState(() {\n        _connected = false;\n      });\n    } catch (e) {\n      debugPrint('Error ending connection: $e');\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"connection-states",children:"Connection States"}),"\n",(0,r.jsx)(n.p,{children:"Monitor connection states to provide appropriate user feedback:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"enum ConnectionState {\n  disconnected,\n  connecting,\n  connected,\n  error,\n}\n\nclass ConnectionManager {\n  ConnectionState _state = ConnectionState.disconnected;\n  String? _errorMessage;\n\n  ConnectionState get state => _state;\n  String? get errorMessage => _errorMessage;\n\n  Future<void> connect() async {\n    _setState(ConnectionState.connecting);\n\n    try {\n      await FlutterInappPurchase.instance.initConnection();\n      _setState(ConnectionState.connected);\n    } catch (e) {\n      _setState(ConnectionState.error, e.toString());\n    }\n  }\n\n  void _setState(ConnectionState newState, [String? error]) {\n    _state = newState;\n    _errorMessage = error;\n    // Notify listeners of state change\n    notifyListeners();\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"component-lifecycle-integration",children:"Component Lifecycle Integration"}),"\n",(0,r.jsx)(n.h3,{id:"class-components",children:"Class Components"}),"\n",(0,r.jsx)(n.p,{children:"Integrate IAP lifecycle with Flutter widget lifecycle:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class PurchaseScreen extends StatefulWidget {\n  @override\n  _PurchaseScreenState createState() => _PurchaseScreenState();\n}\n\nclass _PurchaseScreenState extends State<PurchaseScreen>\n    with WidgetsBindingObserver {\n\n  StreamSubscription<PurchasedItem?>? _purchaseSubscription;\n  StreamSubscription<PurchaseResult?>? _errorSubscription;\n  bool _isProcessing = false;\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addObserver(this);\n    _setupPurchaseListeners();\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    _purchaseSubscription?.cancel();\n    _errorSubscription?.cancel();\n    super.dispose();\n  }\n\n  @override\n  void didChangeAppLifecycleState(AppLifecycleState state) {\n    switch (state) {\n      case AppLifecycleState.resumed:\n        // App resumed - check for pending purchases\n        _checkPendingPurchases();\n        break;\n      case AppLifecycleState.paused:\n        // App paused - save any pending state\n        _savePendingState();\n        break;\n      case AppLifecycleState.detached:\n        // App closing - cleanup resources\n        _cleanup();\n        break;\n      default:\n        break;\n    }\n  }\n\n  void _setupPurchaseListeners() {\n    _purchaseSubscription = FlutterInappPurchase.purchaseUpdated.listen(\n      (purchase) {\n        if (purchase != null && mounted) {\n          setState(() => _isProcessing = false);\n          _handlePurchaseSuccess(purchase);\n        }\n      },\n    );\n\n    _errorSubscription = FlutterInappPurchase.purchaseError.listen(\n      (error) {\n        if (error != null && mounted) {\n          setState(() => _isProcessing = false);\n          _handlePurchaseError(error);\n        }\n      },\n    );\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"functional-components",children:"Functional Components"}),"\n",(0,r.jsx)(n.p,{children:"Using hooks or similar patterns for functional components:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Custom hook for IAP lifecycle management\nclass IapHook {\n  late StreamSubscription<PurchasedItem?>? _purchaseSubscription;\n  late StreamSubscription<PurchaseResult?>? _errorSubscription;\n\n  void initialize(\n    Function(PurchasedItem) onPurchase,\n    Function(PurchaseResult) onError,\n  ) {\n    _purchaseSubscription = FlutterInappPurchase.purchaseUpdated.listen(\n      (purchase) {\n        if (purchase != null) {\n          onPurchase(purchase);\n        }\n      },\n    );\n\n    _errorSubscription = FlutterInappPurchase.purchaseError.listen(\n      (error) {\n        if (error != null) {\n          onError(error);\n        }\n      },\n    );\n  }\n\n  void dispose() {\n    _purchaseSubscription?.cancel();\n    _errorSubscription?.cancel();\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"-do",children:"\u2705 Do:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Initialize connections early"})," in your app lifecycle"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Set up purchase listeners"})," before making any purchase requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle app state changes"})," (background/foreground transitions)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement retry logic"})," for failed connections"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clean up resources"})," properly in dispose methods"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check for pending purchases"})," when app resumes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validate purchases server-side"})," for security"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Provide user feedback"})," during purchase processing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle network interruptions"})," gracefully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test on different devices"})," and OS versions"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Good: Comprehensive lifecycle management\nclass GoodPurchaseManager extends WidgetsBindingObserver {\n  void initialize() {\n    WidgetsBinding.instance.addObserver(this);\n    _setupListeners();\n    _ensureConnection();\n  }\n\n  @override\n  void didChangeAppLifecycleState(AppLifecycleState state) {\n    if (state == AppLifecycleState.resumed) {\n      _checkPendingTransactions();\n    }\n  }\n\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    _cleanup();\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"-dont",children:"\u274c Don't:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Make purchases without listeners"})," set up first"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ignore connection state"})," when making requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Block UI indefinitely"})," during purchase processing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Store sensitive data"})," in local storage"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trust client-side validation"})," alone"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forget to handle edge cases"})," (network issues, app backgrounding)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leave connections open"})," when not needed"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Assume purchases complete immediately"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Skip testing"})," in sandbox environments"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Ignore platform differences"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Bad: No lifecycle management\nclass BadPurchaseManager {\n  void makePurchase(String productId) {\n    // Bad: No connection check\n    // Bad: No listeners set up\n    // Bad: No error handling\n    FlutterInappPurchase.instance.requestPurchase(/*...*/);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"purchase-flow-best-practices",children:"Purchase Flow Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"receipt-validation-and-security",children:"Receipt Validation and Security"}),"\n",(0,r.jsx)(n.p,{children:"Always validate purchases server-side:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class SecurePurchaseValidator {\n  static Future<bool> validatePurchase(PurchasedItem purchase) async {\n    try {\n      if (Platform.isIOS) {\n        // iOS receipt validation\n        final result = await FlutterInappPurchase.instance.validateReceiptIos(\n          receiptBody: {\n            'receipt-data': purchase.transactionReceipt,\n            'password': 'your-shared-secret',\n          },\n          isTest: false, // Set based on environment\n        );\n\n        return result != null && result['status'] == 0;\n      } else if (Platform.isAndroid) {\n        // Android purchase validation\n        final result = await FlutterInappPurchase.instance.validateReceiptAndroid(\n          packageName: 'your.package.name',\n          productId: purchase.productId!,\n          productToken: purchase.purchaseToken!,\n          accessToken: 'your-access-token',\n          isSubscription: false,\n        );\n\n        return result != null;\n      }\n\n      return false;\n    } catch (e) {\n      debugPrint('Validation failed: $e');\n      return false;\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"purchase-state-management",children:"Purchase State Management"}),"\n",(0,r.jsx)(n.p,{children:"Track purchase states throughout the lifecycle:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"enum PurchaseState {\n  idle,\n  loading,\n  processing,\n  validating,\n  delivering,\n  completed,\n  error,\n}\n\nclass PurchaseStateManager {\n  PurchaseState _state = PurchaseState.idle;\n  String? _currentProductId;\n  String? _errorMessage;\n\n  PurchaseState get state => _state;\n  String? get currentProductId => _currentProductId;\n  String? get errorMessage => _errorMessage;\n\n  Future<void> initiatePurchase(String productId) async {\n    _updateState(PurchaseState.loading, productId);\n\n    try {\n      // Check connection\n      final connected = await _ensureConnection();\n      if (!connected) {\n        throw Exception('Store connection failed');\n      }\n\n      _updateState(PurchaseState.processing, productId);\n\n      await FlutterInappPurchase.instance.requestPurchase(\n        request: RequestPurchase(\n          ios: RequestPurchaseIOS(sku: productId),\n          android: RequestPurchaseAndroid(skus: [productId]),\n        ),\n        type: PurchaseType.inapp,\n      );\n\n    } catch (e) {\n      _updateState(PurchaseState.error, productId, e.toString());\n    }\n  }\n\n  void _updateState(PurchaseState newState, [String? productId, String? error]) {\n    _state = newState;\n    _currentProductId = productId;\n    _errorMessage = error;\n    notifyListeners();\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling-and-user-experience",children:"Error Handling and User Experience"}),"\n",(0,r.jsx)(n.h3,{id:"comprehensive-error-handling",children:"Comprehensive Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class PurchaseErrorHandler {\n  static void handlePurchaseError(PurchaseResult error, BuildContext context) {\n    String userMessage;\n    bool shouldRetry = false;\n\n    switch (error.responseCode) {\n      case 1: // User cancelled\n        userMessage = 'Purchase was cancelled';\n        break;\n      case 2: // Network error\n        userMessage = 'Network error. Please check your connection and try again.';\n        shouldRetry = true;\n        break;\n      case 3: // Billing unavailable\n        userMessage = 'Purchases are not available on this device';\n        break;\n      case 4: // Item unavailable\n        userMessage = 'This item is currently unavailable';\n        break;\n      case 5: // Developer error\n        userMessage = 'Configuration error. Please try again later.';\n        break;\n      case 7: // Item already owned\n        userMessage = 'You already own this item';\n        _handleAlreadyOwned(error);\n        return;\n      default:\n        userMessage = 'Purchase failed: ${error.message ?? 'Unknown error'}';\n    }\n\n    _showErrorDialog(context, userMessage, shouldRetry);\n  }\n\n  static void _showErrorDialog(BuildContext context, String message, bool showRetry) {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: Text('Purchase Error'),\n        content: Text(message),\n        actions: [\n          if (showRetry)\n            TextButton(\n              onPressed: () {\n                Navigator.pop(context);\n                // Implement retry logic\n              },\n              child: Text('Retry'),\n            ),\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: Text('OK'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing-and-development",children:"Testing and Development"}),"\n",(0,r.jsx)(n.h3,{id:"development-environment-setup",children:"Development Environment Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"class DevelopmentHelpers {\n  static bool get isDebugMode => kDebugMode;\n\n  static Future<void> setupTestEnvironment() async {\n    if (!isDebugMode) return;\n\n    // Clear any existing transactions in debug mode\n    try {\n      await FlutterInappPurchase.instance.clearTransactionCache();\n      debugPrint('Cleared transaction cache for testing');\n    } catch (e) {\n      debugPrint('Failed to clear transaction cache: $e');\n    }\n  }\n\n  static void logPurchaseState(String state, [Map<String, dynamic>? data]) {\n    if (!isDebugMode) return;\n\n    debugPrint('Purchase State: $state');\n    if (data != null) {\n      data.forEach((key, value) {\n        debugPrint('  $key: $value');\n      });\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,r.jsx)(n.h3,{id:"transaction-management-issues",children:"Transaction Management Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Purchases getting stuck in pending state"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Solution: Implement proper transaction cleanup\nclass TransactionCleanup {\n  static Future<void> cleanupPendingTransactions() async {\n    try {\n      // Restore purchases to get all pending transactions\n      await FlutterInappPurchase.instance.restorePurchases();\n\n      // Get available purchases\n      final purchases = await FlutterInappPurchase.instance.getAvailablePurchases();\n\n      // Process each pending purchase\n      for (final purchase in purchases) {\n        await _finalizePurchase(purchase);\n      }\n    } catch (e) {\n      debugPrint('Error cleaning up transactions: $e');\n    }\n  }\n\n  static Future<void> _finalizePurchase(PurchasedItem purchase) async {\n    // Validate and deliver content first\n    final isValid = await _validatePurchase(purchase);\n    if (!isValid) return;\n\n    await _deliverContent(purchase);\n\n    // Then finalize the transaction\n    if (Platform.isAndroid) {\n      await FlutterInappPurchase.instance.consumePurchaseAndroid(\n        purchaseToken: purchase.purchaseToken!,\n      );\n    } else if (Platform.isIOS) {\n      await FlutterInappPurchase.instance.finishTransactionIOS(\n        purchase,\n        isConsumable: _isConsumable(purchase.productId),\n      );\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"security-issues",children:"Security Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Client-side only validation"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Solution: Always validate server-side\nclass SecurityBestPractices {\n  static Future<bool> secureValidation(PurchasedItem purchase) async {\n    // 1. Client-side basic checks\n    if (purchase.productId == null || purchase.transactionReceipt == null) {\n      return false;\n    }\n\n    // 2. Server-side validation (critical)\n    final serverValid = await _validateWithServer(purchase);\n    if (!serverValid) return false;\n\n    // 3. Business logic validation\n    final businessValid = await _validateBusinessRules(purchase);\n\n    return businessValid;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"development-and-testing-issues",children:"Development and Testing Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Different behavior in sandbox vs production"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Solution: Environment-aware configuration\nclass EnvironmentConfig {\n  static bool get isProduction => !kDebugMode && _isProductionBuild();\n  static bool get isSandbox => kDebugMode || _isSandboxBuild();\n\n  static String get validationEndpoint => isProduction\n    ? 'https://buy.itunes.apple.com/verifyReceipt'\n    : 'https://sandbox.itunes.apple.com/verifyReceipt';\n\n  static bool _isProductionBuild() {\n    // Add your production detection logic\n    return false;\n  }\n\n  static bool _isSandboxBuild() {\n    // Add your sandbox detection logic\n    return true;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"app-lifecycle-issues",children:"App Lifecycle Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Purchases interrupted by app backgrounding"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Solution: Implement proper app lifecycle handling\nclass LifecycleAwarePurchaseManager extends WidgetsBindingObserver {\n  Map<String, PurchaseState> _pendingPurchases = {};\n\n  @override\n  void didChangeAppLifecycleState(AppLifecycleState state) {\n    switch (state) {\n      case AppLifecycleState.resumed:\n        _resumePendingPurchases();\n        break;\n      case AppLifecycleState.paused:\n        _savePendingPurchases();\n        break;\n      default:\n        break;\n    }\n  }\n\n  void _resumePendingPurchases() {\n    // Check for any purchases that completed while app was backgrounded\n    FlutterInappPurchase.instance.restorePurchases();\n  }\n\n  void _savePendingPurchases() {\n    // Persist pending purchase state\n    // This helps recover from app kills during purchase\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"connection-management-issues",children:"Connection Management Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Connection drops during purchase flow"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"// Solution: Implement connection resilience\nclass ResilientConnectionManager {\n  static Future<bool> ensureConnectionWithRetry() async {\n    for (int attempt = 1; attempt <= 3; attempt++) {\n      try {\n        await FlutterInappPurchase.instance.initConnection();\n        return true;\n      } catch (e) {\n        debugPrint('Connection attempt $attempt failed: $e');\n\n        if (attempt < 3) {\n          await Future.delayed(Duration(seconds: attempt * 2));\n        }\n      }\n    }\n\n    return false;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"After implementing proper lifecycle management:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test thoroughly"})," in both sandbox and production environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor purchase analytics"})," to identify lifecycle issues"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement proper logging"})," for debugging purchase flows"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Set up alerts"})," for purchase failures and anomalies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Review and optimize"})," purchase success rates"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider advanced features"})," like promotional offers and subscription management"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For more detailed guidance on specific purchase flows, see:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/6.3/guides/purchases",children:"Purchases Guide"})," - Complete purchase implementation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/6.3/guides/offer-code-redemption",children:"Offer Code Redemption"})," - Promotional offers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/docs/6.3/guides/troubleshooting",children:"Troubleshooting"})," - Common issues and solutions"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var t=s(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);