"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[7091],{6565:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"api/methods/validate-receipt","title":"validateReceipt","description":"Validates purchase receipts with platform verification services.","source":"@site/versioned_docs/version-6.3/api/methods/validate-receipt.md","sourceDirName":"api/methods","slug":"/api/methods/validate-receipt","permalink":"/docs/6.3/api/methods/validate-receipt","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/versioned_docs/version-6.3/api/methods/validate-receipt.md","tags":[],"version":"6.3","sidebarPosition":8,"frontMatter":{"sidebar_position":8,"title":"validateReceipt"}}');var a=i(4848),r=i(8453);const s={sidebar_position:8,title:"validateReceipt"},o="validateReceipt()",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Methods",id:"methods",level:2},{value:"iOS Receipt Validation",id:"ios-receipt-validation",level:3},{value:"Android Receipt Validation",id:"android-receipt-validation",level:3},{value:"iOS Receipt Validation",id:"ios-receipt-validation-1",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Complete iOS Implementation",id:"complete-ios-implementation",level:3},{value:"Android Receipt Validation",id:"android-receipt-validation-1",level:2},{value:"Basic Usage",id:"basic-usage-1",level:3},{value:"Complete Android Implementation",id:"complete-android-implementation",level:3},{value:"Server-Side Validation (Recommended)",id:"server-side-validation-recommended",level:2},{value:"Receipt Validation Flow",id:"receipt-validation-flow",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Related Methods",id:"related-methods",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"validatereceipt",children:"validateReceipt()"})}),"\n",(0,a.jsx)(n.p,{children:"Validates purchase receipts with platform verification services."}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"Receipt validation is crucial for verifying the authenticity of purchases. This plugin provides methods to validate receipts with Apple's and Google's verification services, though server-side validation is recommended for production apps."}),"\n",(0,a.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(n.h3,{id:"ios-receipt-validation",children:"iOS Receipt Validation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"Future<http.Response> validateReceiptIos({\n  required Map<String, String> receiptBody,\n  bool isTest = true,\n})\n"})}),"\n",(0,a.jsx)(n.h3,{id:"android-receipt-validation",children:"Android Receipt Validation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"Future<http.Response> validateReceiptAndroid({\n  required String packageName,\n  required String productId,\n  required String productToken,\n  required String accessToken,\n  bool isSubscription = false,\n})\n"})}),"\n",(0,a.jsx)(n.h2,{id:"ios-receipt-validation-1",children:"iOS Receipt Validation"}),"\n",(0,a.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"import 'dart:convert';\n\nFuture<bool> validateIosReceipt(String receiptData) async {\n  try {\n    final response = await FlutterInappPurchase.instance.validateReceiptIos(\n      receiptBody: {\n        'receipt-data': receiptData,\n        'password': 'your-app-shared-secret', // For subscriptions\n      },\n      isTest: true, // Use sandbox for testing\n    );\n    \n    if (response.statusCode == 200) {\n      final data = json.decode(response.body);\n      final status = data['status'];\n      \n      switch (status) {\n        case 0:\n          print('Receipt is valid');\n          return true;\n        case 21007:\n          // Receipt is from sandbox, retry with sandbox URL\n          return validateIosReceipt(receiptData);\n        case 21008:\n          // Receipt is from production, retry with production URL\n          return validateIosReceipt(receiptData);\n        default:\n          print('Invalid receipt: Status $status');\n          return false;\n      }\n    }\n    \n    return false;\n  } catch (e) {\n    print('Receipt validation error: $e');\n    return false;\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"complete-ios-implementation",children:"Complete iOS Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class IosReceiptValidator {\n  final String sharedSecret;\n  \n  IosReceiptValidator({required this.sharedSecret});\n  \n  Future<ReceiptValidationResult> validate(PurchasedItem purchase) async {\n    if (purchase.transactionReceipt == null) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'No receipt data',\n      );\n    }\n    \n    try {\n      // Try production first\n      var response = await _validateWithUrl(\n        purchase.transactionReceipt!,\n        isProduction: true,\n      );\n      \n      var result = _parseResponse(response);\n      \n      // If sandbox receipt, retry with sandbox\n      if (result.status == 21007) {\n        response = await _validateWithUrl(\n          purchase.transactionReceipt!,\n          isProduction: false,\n        );\n        result = _parseResponse(response);\n      }\n      \n      return result;\n      \n    } catch (e) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: e.toString(),\n      );\n    }\n  }\n  \n  Future<http.Response> _validateWithUrl(\n    String receiptData,\n    {required bool isProduction}\n  ) async {\n    return await FlutterInappPurchase.instance.validateReceiptIos(\n      receiptBody: {\n        'receipt-data': receiptData,\n        'password': sharedSecret,\n        'exclude-old-transactions': 'true',\n      },\n      isTest: !isProduction,\n    );\n  }\n  \n  ReceiptValidationResult _parseResponse(http.Response response) {\n    if (response.statusCode != 200) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'HTTP ${response.statusCode}',\n      );\n    }\n    \n    final data = json.decode(response.body);\n    final status = data['status'] as int;\n    \n    if (status == 0) {\n      // Extract purchase info\n      final receipt = data['receipt'];\n      final latestInfo = data['latest_receipt_info'];\n      \n      return ReceiptValidationResult(\n        isValid: true,\n        status: status,\n        receipt: receipt,\n        latestPurchases: latestInfo,\n      );\n    }\n    \n    return ReceiptValidationResult(\n      isValid: false,\n      status: status,\n      error: _getErrorMessage(status),\n    );\n  }\n  \n  String _getErrorMessage(int status) {\n    switch (status) {\n      case 21000: return 'App Store could not read the receipt';\n      case 21002: return 'Receipt data was malformed';\n      case 21003: return 'Receipt could not be authenticated';\n      case 21004: return 'Shared secret does not match';\n      case 21005: return 'Receipt server is unavailable';\n      case 21006: return 'Receipt is valid but subscription expired';\n      case 21007: return 'Receipt is from sandbox environment';\n      case 21008: return 'Receipt is from production environment';\n      default: return 'Unknown error: $status';\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"android-receipt-validation-1",children:"Android Receipt Validation"}),"\n",(0,a.jsx)(n.h3,{id:"basic-usage-1",children:"Basic Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"Future<bool> validateAndroidReceipt(PurchasedItem purchase) async {\n  try {\n    // Get access token (implement OAuth 2.0 flow)\n    final accessToken = await _getGoogleAccessToken();\n    \n    final response = await FlutterInappPurchase.instance.validateReceiptAndroid(\n      packageName: 'com.example.app',\n      productId: purchase.productId!,\n      productToken: purchase.purchaseToken!,\n      accessToken: accessToken,\n      isSubscription: _isSubscription(purchase.productId),\n    );\n    \n    if (response.statusCode == 200) {\n      final data = json.decode(response.body);\n      \n      // Check purchase state\n      final purchaseState = data['purchaseState'];\n      if (purchaseState == 0) { // Purchased\n        print('Purchase is valid');\n        return true;\n      }\n    }\n    \n    return false;\n  } catch (e) {\n    print('Android receipt validation error: $e');\n    return false;\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"complete-android-implementation",children:"Complete Android Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class AndroidReceiptValidator {\n  final String packageName;\n  final GoogleAuthService authService;\n  \n  AndroidReceiptValidator({\n    required this.packageName,\n    required this.authService,\n  });\n  \n  Future<ReceiptValidationResult> validate(PurchasedItem purchase) async {\n    if (purchase.purchaseToken == null) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'No purchase token',\n      );\n    }\n    \n    try {\n      // Get fresh access token\n      final accessToken = await authService.getAccessToken();\n      \n      final response = await FlutterInappPurchase.instance.validateReceiptAndroid(\n        packageName: packageName,\n        productId: purchase.productId!,\n        productToken: purchase.purchaseToken!,\n        accessToken: accessToken,\n        isSubscription: _isSubscription(purchase.productId),\n      );\n      \n      return _parseResponse(response, purchase);\n      \n    } catch (e) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: e.toString(),\n      );\n    }\n  }\n  \n  ReceiptValidationResult _parseResponse(\n    http.Response response,\n    PurchasedItem purchase,\n  ) {\n    if (response.statusCode == 404) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'Purchase not found',\n      );\n    }\n    \n    if (response.statusCode == 401) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'Authentication failed',\n      );\n    }\n    \n    if (response.statusCode != 200) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'HTTP ${response.statusCode}',\n      );\n    }\n    \n    final data = json.decode(response.body);\n    \n    // For products\n    if (!_isSubscription(purchase.productId)) {\n      final purchaseState = data['purchaseState'];\n      final consumptionState = data['consumptionState'];\n      \n      return ReceiptValidationResult(\n        isValid: purchaseState == 0,\n        purchaseState: purchaseState,\n        isConsumed: consumptionState == 1,\n        originalData: data,\n      );\n    }\n    \n    // For subscriptions\n    final expiryTime = data['expiryTimeMillis'];\n    final isExpired = expiryTime != null && \n      DateTime.fromMillisecondsSinceEpoch(int.parse(expiryTime))\n          .isBefore(DateTime.now());\n    \n    return ReceiptValidationResult(\n      isValid: !isExpired,\n      expiryDate: expiryTime != null \n          ? DateTime.fromMillisecondsSinceEpoch(int.parse(expiryTime))\n          : null,\n      originalData: data,\n    );\n  }\n  \n  bool _isSubscription(String? productId) {\n    // Implement your logic to determine if product is subscription\n    return productId?.contains('subscription') ?? false;\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"server-side-validation-recommended",children:"Server-Side Validation (Recommended)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class ServerReceiptValidator {\n  final String serverUrl;\n  final http.Client httpClient;\n  \n  ServerReceiptValidator({\n    required this.serverUrl,\n    required this.httpClient,\n  });\n  \n  Future<bool> validate(PurchasedItem purchase) async {\n    try {\n      final payload = {\n        'platform': Platform.isIOS ? 'ios' : 'android',\n        'productId': purchase.productId,\n        'transactionId': purchase.transactionId,\n        'receipt': Platform.isIOS \n            ? purchase.transactionReceipt \n            : purchase.dataAndroid,\n        'signature': Platform.isAndroid ? purchase.signatureAndroid : null,\n        'purchaseToken': Platform.isAndroid ? purchase.purchaseToken : null,\n      };\n      \n      final response = await httpClient.post(\n        Uri.parse('$serverUrl/validate-receipt'),\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': 'Bearer ${await _getAuthToken()}',\n        },\n        body: json.encode(payload),\n      );\n      \n      if (response.statusCode == 200) {\n        final result = json.decode(response.body);\n        return result['valid'] == true;\n      }\n      \n      return false;\n      \n    } catch (e) {\n      print('Server validation error: $e');\n      return false;\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"receipt-validation-flow",children:"Receipt Validation Flow"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-dart",children:"class PurchaseValidator {\n  final ServerReceiptValidator serverValidator;\n  final IosReceiptValidator iosValidator;\n  final AndroidReceiptValidator androidValidator;\n  \n  Future<void> validatePurchase(PurchasedItem purchase) async {\n    try {\n      // Always prefer server-side validation\n      if (await serverValidator.validate(purchase)) {\n        print('Server validation successful');\n        await _completePurchase(purchase);\n        return;\n      }\n      \n      // Fallback to client-side validation\n      print('Server validation failed, trying client-side');\n      \n      ReceiptValidationResult result;\n      if (Platform.isIOS) {\n        result = await iosValidator.validate(purchase);\n      } else {\n        result = await androidValidator.validate(purchase);\n      }\n      \n      if (result.isValid) {\n        await _completePurchase(purchase);\n      } else {\n        print('Validation failed: ${result.error}');\n        // Don't complete invalid purchases\n      }\n      \n    } catch (e) {\n      print('Validation error: $e');\n      // Keep purchase pending for retry\n    }\n  }\n  \n  Future<void> _completePurchase(PurchasedItem purchase) async {\n    // Deliver content\n    await _deliverContent(purchase.productId!);\n    \n    // Finish transaction\n    await FlutterInappPurchase.instance.finishTransactionIOS(\n      purchase,\n      isConsumable: _isConsumable(purchase.productId),\n    );\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Always Use Server Validation"}),": Client-side validation can be bypassed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validate Before Delivery"}),": Never deliver content before validation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handle Network Errors"}),": Implement retry logic for validation failures"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cache Valid Receipts"}),": Avoid repeated validation of same receipt"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Check Expiration"}),": For subscriptions, verify they're still active"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Secure Credentials"}),": Never hardcode shared secrets or access tokens"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Shared Secret"}),": Store iOS shared secret securely on server"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Access Tokens"}),": Use OAuth 2.0 service account for Android"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"HTTPS Only"}),": Always use secure connections"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Receipt Storage"}),": Store receipts for audit trail"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fraud Detection"}),": Implement additional fraud checks server-side"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"related-methods",children:"Related Methods"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/6.3/api/methods/get-available-purchases",children:(0,a.jsx)(n.code,{children:"getAvailablePurchases()"})})," - Get purchases to validate"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"/docs/6.3/api/methods/finish-transaction",children:(0,a.jsx)(n.code,{children:"finishTransaction()"})})," - Complete validated purchases"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getPurchaseHistory()"})," - Get historical receipts (Android only)"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(6540);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);