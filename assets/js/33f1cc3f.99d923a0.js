"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[3439],{5501:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"guides/receipt-validation","title":"Receipt Validation","description":"Comprehensive guide to validating purchase receipts for security and fraud prevention.","source":"@site/docs/guides/receipt-validation.md","sourceDirName":"guides","slug":"/guides/receipt-validation","permalink":"/docs/guides/receipt-validation","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/docs/guides/receipt-validation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Receipt Validation"}}');var t=i(4848),r=i(8453);const s={sidebar_position:4,title:"Receipt Validation"},l="Receipt Validation Guide",d={},c=[{value:"Overview",id:"overview",level:2},{value:"Why Validate Receipts?",id:"why-validate-receipts",level:2},{value:"Validation Approaches",id:"validation-approaches",level:2},{value:"Client-Side Validation",id:"client-side-validation",level:3},{value:"Server-Side Validation (Recommended)",id:"server-side-validation-recommended",level:3},{value:"iOS Receipt Validation",id:"ios-receipt-validation",level:2},{value:"Basic Client-Side Validation",id:"basic-client-side-validation",level:3},{value:"Advanced iOS Validation",id:"advanced-ios-validation",level:3},{value:"Android Receipt Validation",id:"android-receipt-validation",level:2},{value:"Basic Client-Side Validation",id:"basic-client-side-validation-1",level:3},{value:"Advanced Android Validation",id:"advanced-android-validation",level:3},{value:"Server-Side Validation (Recommended)",id:"server-side-validation-recommended-1",level:2},{value:"Server Validation Service",id:"server-validation-service",level:3},{value:"Complete Validation Flow",id:"complete-validation-flow",level:2},{value:"Unified Validation Manager",id:"unified-validation-manager",level:3},{value:"Integration with Purchase Flow",id:"integration-with-purchase-flow",level:3},{value:"Receipt Storage and Caching",id:"receipt-storage-and-caching",level:2},{value:"Receipt Cache Manager",id:"receipt-cache-manager",level:3},{value:"Testing Receipt Validation",id:"testing-receipt-validation",level:2},{value:"Test Receipt Generator",id:"test-receipt-generator",level:3},{value:"Validation Testing",id:"validation-testing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"receipt-validation-guide",children:"Receipt Validation Guide"})}),"\n",(0,t.jsx)(n.p,{children:"Comprehensive guide to validating purchase receipts for security and fraud prevention."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Receipt validation is crucial for verifying the authenticity of purchases and preventing fraud. This guide covers both client-side and server-side validation approaches for iOS and Android platforms."}),"\n",(0,t.jsx)(n.h2,{id:"why-validate-receipts",children:"Why Validate Receipts?"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Security"}),": Prevent fraudulent purchases and hacked clients"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Accuracy"}),": Ensure purchase data integrity"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Compliance"}),": Meet platform requirements for purchase verification"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Analytics"}),": Track legitimate purchases for business metrics"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Support"}),": Resolve customer purchase issues"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"validation-approaches",children:"Validation Approaches"}),"\n",(0,t.jsx)(n.h3,{id:"client-side-validation",children:"Client-Side Validation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Quick verification for immediate feedback"}),"\n",(0,t.jsx)(n.li,{children:"Can be bypassed by malicious users"}),"\n",(0,t.jsx)(n.li,{children:"Suitable for non-critical features"}),"\n",(0,t.jsx)(n.li,{children:"Should be combined with server-side validation"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"server-side-validation-recommended",children:"Server-Side Validation (Recommended)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Secure and tamper-proof"}),"\n",(0,t.jsx)(n.li,{children:"Required for premium features"}),"\n",(0,t.jsx)(n.li,{children:"Enables purchase analytics and support"}),"\n",(0,t.jsx)(n.li,{children:"Protects against client-side manipulation"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"ios-receipt-validation",children:"iOS Receipt Validation"}),"\n",(0,t.jsx)(n.h3,{id:"basic-client-side-validation",children:"Basic Client-Side Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"class IOSReceiptValidator {\n  final String sharedSecret;\n  \n  IOSReceiptValidator({required this.sharedSecret});\n  \n  Future<ReceiptValidationResult> validateReceipt(String receiptData) async {\n    try {\n      // Try production first\n      var result = await _validateWithApple(receiptData, isProduction: true);\n      \n      // If sandbox receipt, retry with sandbox\n      if (result.status == 21007) {\n        result = await _validateWithApple(receiptData, isProduction: false);\n      }\n      \n      return result;\n      \n    } catch (e) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: e.toString(),\n      );\n    }\n  }\n  \n  Future<ReceiptValidationResult> _validateWithApple(\n    String receiptData, {\n    required bool isProduction,\n  }) async {\n    final response = await FlutterInappPurchase.instance.validateReceiptIos(\n      receiptBody: {\n        'receipt-data': receiptData,\n        'password': sharedSecret,\n        'exclude-old-transactions': 'true',\n      },\n      isTest: !isProduction,\n    );\n    \n    return _parseAppleResponse(response);\n  }\n  \n  ReceiptValidationResult _parseAppleResponse(http.Response response) {\n    if (response.statusCode != 200) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'HTTP ${response.statusCode}',\n      );\n    }\n    \n    final data = json.decode(response.body);\n    final status = data['status'] as int;\n    \n    return ReceiptValidationResult(\n      isValid: status == 0,\n      status: status,\n      receipt: data['receipt'],\n      latestReceiptInfo: data['latest_receipt_info'],\n      pendingRenewalInfo: data['pending_renewal_info'],\n      error: status != 0 ? _getAppleErrorMessage(status) : null,\n    );\n  }\n  \n  String _getAppleErrorMessage(int status) {\n    switch (status) {\n      case 21000: return 'App Store could not read the receipt';\n      case 21002: return 'Receipt data was malformed';\n      case 21003: return 'Receipt could not be authenticated';\n      case 21004: return 'Shared secret does not match';\n      case 21005: return 'Receipt server is unavailable';\n      case 21006: return 'Receipt is valid but subscription expired';\n      case 21007: return 'Receipt is from sandbox environment';\n      case 21008: return 'Receipt is from production environment';\n      default: return 'Unknown error: $status';\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-ios-validation",children:"Advanced iOS Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"class AdvancedIOSValidator {\n  Future<ValidationResult> validatePurchase(PurchasedItem purchase) async {\n    if (purchase.transactionReceipt == null) {\n      return ValidationResult(isValid: false, error: 'No receipt data');\n    }\n    \n    try {\n      final validator = IOSReceiptValidator(\n        sharedSecret: await _getSharedSecret(),\n      );\n      \n      final result = await validator.validateReceipt(\n        purchase.transactionReceipt!,\n      );\n      \n      if (!result.isValid) {\n        return ValidationResult(\n          isValid: false,\n          error: result.error,\n        );\n      }\n      \n      // Verify specific transaction\n      final transactionInfo = _findTransaction(\n        result.latestReceiptInfo,\n        purchase.transactionId,\n      );\n      \n      if (transactionInfo == null) {\n        return ValidationResult(\n          isValid: false,\n          error: 'Transaction not found in receipt',\n        );\n      }\n      \n      // Additional validations\n      if (!_validateBundleId(result.receipt)) {\n        return ValidationResult(\n          isValid: false,\n          error: 'Bundle ID mismatch',\n        );\n      }\n      \n      if (!_validateEnvironment(result.receipt)) {\n        return ValidationResult(\n          isValid: false,\n          error: 'Environment mismatch',\n        );\n      }\n      \n      return ValidationResult(\n        isValid: true,\n        transactionInfo: transactionInfo,\n        receiptInfo: result.receipt,\n      );\n      \n    } catch (e) {\n      return ValidationResult(\n        isValid: false,\n        error: e.toString(),\n      );\n    }\n  }\n  \n  Map<String, dynamic>? _findTransaction(\n    List<dynamic>? receiptInfo,\n    String? transactionId,\n  ) {\n    if (receiptInfo == null || transactionId == null) return null;\n    \n    return receiptInfo\n        .cast<Map<String, dynamic>>()\n        .firstWhere(\n          (transaction) => transaction['transaction_id'] == transactionId,\n          orElse: () => null,\n        );\n  }\n  \n  bool _validateBundleId(Map<String, dynamic> receipt) {\n    final bundleId = receipt['bundle_id'] as String?;\n    return bundleId == await _getExpectedBundleId();\n  }\n  \n  bool _validateEnvironment(Map<String, dynamic> receipt) {\n    final environment = receipt['environment'] as String?;\n    return environment == (kDebugMode ? 'Sandbox' : 'Production');\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"android-receipt-validation",children:"Android Receipt Validation"}),"\n",(0,t.jsx)(n.h3,{id:"basic-client-side-validation-1",children:"Basic Client-Side Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"class AndroidReceiptValidator {\n  final String packageName;\n  final GoogleAuthService authService;\n  \n  AndroidReceiptValidator({\n    required this.packageName,\n    required this.authService,\n  });\n  \n  Future<ReceiptValidationResult> validateReceipt(PurchasedItem purchase) async {\n    if (purchase.purchaseToken == null) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'No purchase token',\n      );\n    }\n    \n    try {\n      final accessToken = await authService.getAccessToken();\n      \n      final response = await FlutterInappPurchase.instance.validateReceiptAndroid(\n        packageName: packageName,\n        productId: purchase.productId!,\n        productToken: purchase.purchaseToken!,\n        accessToken: accessToken,\n        isSubscription: _isSubscription(purchase.productId),\n      );\n      \n      return _parseGoogleResponse(response, purchase);\n      \n    } catch (e) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: e.toString(),\n      );\n    }\n  }\n  \n  ReceiptValidationResult _parseGoogleResponse(\n    http.Response response,\n    PurchasedItem purchase,\n  ) {\n    if (response.statusCode == 404) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'Purchase not found',\n      );\n    }\n    \n    if (response.statusCode == 401) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'Authentication failed',\n      );\n    }\n    \n    if (response.statusCode != 200) {\n      return ReceiptValidationResult(\n        isValid: false,\n        error: 'HTTP ${response.statusCode}',\n      );\n    }\n    \n    final data = json.decode(response.body);\n    \n    if (_isSubscription(purchase.productId)) {\n      return _validateSubscriptionResponse(data);\n    } else {\n      return _validateProductResponse(data);\n    }\n  }\n  \n  ReceiptValidationResult _validateProductResponse(Map<String, dynamic> data) {\n    final purchaseState = data['purchaseState'] as int?;\n    final consumptionState = data['consumptionState'] as int?;\n    \n    return ReceiptValidationResult(\n      isValid: purchaseState == 0, // Purchased\n      purchaseState: purchaseState,\n      isConsumed: consumptionState == 1,\n      originalData: data,\n    );\n  }\n  \n  ReceiptValidationResult _validateSubscriptionResponse(\n    Map<String, dynamic> data,\n  ) {\n    final expiryTimeMillis = data['expiryTimeMillis'] as String?;\n    final autoRenewing = data['autoRenewing'] as bool?;\n    \n    DateTime? expiryDate;\n    if (expiryTimeMillis != null) {\n      expiryDate = DateTime.fromMillisecondsSinceEpoch(\n        int.parse(expiryTimeMillis),\n      );\n    }\n    \n    final isExpired = expiryDate?.isBefore(DateTime.now()) ?? true;\n    \n    return ReceiptValidationResult(\n      isValid: !isExpired,\n      expiryDate: expiryDate,\n      autoRenewing: autoRenewing,\n      originalData: data,\n    );\n  }\n  \n  bool _isSubscription(String? productId) {\n    // Implement your logic to determine if product is subscription\n    return productId?.contains('subscription') ?? false;\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-android-validation",children:"Advanced Android Validation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"class AdvancedAndroidValidator {\n  Future<ValidationResult> validatePurchaseWithSignature(\n    PurchasedItem purchase,\n  ) async {\n    // First validate signature locally for quick check\n    if (!_validateSignature(purchase)) {\n      return ValidationResult(\n        isValid: false,\n        error: 'Invalid signature',\n      );\n    }\n    \n    // Then validate with Google Play API\n    final validator = AndroidReceiptValidator(\n      packageName: await _getPackageName(),\n      authService: GoogleAuthService(),\n    );\n    \n    final result = await validator.validateReceipt(purchase);\n    \n    if (!result.isValid) {\n      return ValidationResult(\n        isValid: false,\n        error: result.error,\n      );\n    }\n    \n    // Additional security checks\n    if (!_validatePurchaseTime(purchase, result.originalData)) {\n      return ValidationResult(\n        isValid: false,\n        error: 'Purchase time validation failed',\n      );\n    }\n    \n    return ValidationResult(\n      isValid: true,\n      receiptData: result.originalData,\n    );\n  }\n  \n  bool _validateSignature(PurchasedItem purchase) {\n    if (purchase.dataAndroid == null || \n        purchase.signatureAndroid == null) {\n      return false;\n    }\n    \n    try {\n      // Implement signature validation using Google Play's public key\n      return SignatureValidator.verify(\n        data: purchase.dataAndroid!,\n        signature: purchase.signatureAndroid!,\n        publicKey: await _getGooglePlayPublicKey(),\n      );\n    } catch (e) {\n      print('Signature validation error: $e');\n      return false;\n    }\n  }\n  \n  bool _validatePurchaseTime(\n    PurchasedItem purchase,\n    Map<String, dynamic>? receiptData,\n  ) {\n    if (receiptData == null) return true;\n    \n    final purchaseTimeMillis = receiptData['purchaseTimeMillis'] as String?;\n    if (purchaseTimeMillis == null) return true;\n    \n    final receiptTime = DateTime.fromMillisecondsSinceEpoch(\n      int.parse(purchaseTimeMillis),\n    );\n    \n    final localTime = purchase.transactionDate;\n    if (localTime == null) return true;\n    \n    // Allow some variance for clock differences\n    final timeDifference = receiptTime.difference(localTime).inMinutes.abs();\n    return timeDifference <= 5; // 5 minutes tolerance\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"server-side-validation-recommended-1",children:"Server-Side Validation (Recommended)"}),"\n",(0,t.jsx)(n.h3,{id:"server-validation-service",children:"Server Validation Service"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"class ServerValidationService {\n  final String baseUrl;\n  final http.Client httpClient;\n  \n  ServerValidationService({\n    required this.baseUrl,\n    required this.httpClient,\n  });\n  \n  Future<ServerValidationResult> validatePurchase(\n    PurchasedItem purchase,\n  ) async {\n    try {\n      final payload = _buildValidationPayload(purchase);\n      \n      final response = await httpClient.post(\n        Uri.parse('$baseUrl/validate-purchase'),\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': 'Bearer ${await _getAuthToken()}',\n        },\n        body: json.encode(payload),\n      );\n      \n      return _parseServerResponse(response);\n      \n    } catch (e) {\n      return ServerValidationResult(\n        isValid: false,\n        error: e.toString(),\n      );\n    }\n  }\n  \n  Map<String, dynamic> _buildValidationPayload(PurchasedItem purchase) {\n    return {\n      'platform': Platform.isIOS ? 'ios' : 'android',\n      'productId': purchase.productId,\n      'transactionId': purchase.transactionId,\n      'purchaseTime': purchase.transactionDate?.millisecondsSinceEpoch,\n      \n      // iOS specific\n      if (Platform.isIOS) ...{\n        'receipt': purchase.transactionReceipt,\n        'originalTransactionId': purchase.originalTransactionIdentifierIOS,\n      },\n      \n      // Android specific\n      if (Platform.isAndroid) ...{\n        'purchaseToken': purchase.purchaseToken,\n        'purchaseData': purchase.dataAndroid,\n        'signature': purchase.signatureAndroid,\n        'packageName': await _getPackageName(),\n      },\n      \n      // User identification\n      'userId': await _getUserId(),\n      'deviceId': await _getDeviceId(),\n    };\n  }\n  \n  ServerValidationResult _parseServerResponse(http.Response response) {\n    if (response.statusCode != 200) {\n      return ServerValidationResult(\n        isValid: false,\n        error: 'Server error: ${response.statusCode}',\n      );\n    }\n    \n    final data = json.decode(response.body);\n    \n    return ServerValidationResult(\n      isValid: data['valid'] == true,\n      transactionId: data['transactionId'],\n      productId: data['productId'],\n      purchaseDate: data['purchaseDate'] != null\n          ? DateTime.parse(data['purchaseDate'])\n          : null,\n      expiryDate: data['expiryDate'] != null\n          ? DateTime.parse(data['expiryDate'])\n          : null,\n      isSubscription: data['isSubscription'] == true,\n      originalJson: data['originalReceipt'],\n      error: data['error'],\n    );\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"complete-validation-flow",children:"Complete Validation Flow"}),"\n",(0,t.jsx)(n.h3,{id:"unified-validation-manager",children:"Unified Validation Manager"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"class PurchaseValidationManager {\n  final ServerValidationService serverValidator;\n  final IOSReceiptValidator iosValidator;\n  final AndroidReceiptValidator androidValidator;\n  \n  PurchaseValidationManager({\n    required this.serverValidator,\n    required this.iosValidator,\n    required this.androidValidator,\n  });\n  \n  Future<bool> validatePurchase(PurchasedItem purchase) async {\n    try {\n      // Always try server validation first\n      final serverResult = await serverValidator.validatePurchase(purchase);\n      \n      if (serverResult.isValid) {\n        print('Server validation successful');\n        return true;\n      }\n      \n      print('Server validation failed: ${serverResult.error}');\n      \n      // Fallback to client-side validation\n      return await _fallbackValidation(purchase);\n      \n    } catch (e) {\n      print('Validation error: $e');\n      \n      // If server is unreachable, use client-side validation\n      return await _fallbackValidation(purchase);\n    }\n  }\n  \n  Future<bool> _fallbackValidation(PurchasedItem purchase) async {\n    print('Using client-side validation as fallback');\n    \n    try {\n      if (Platform.isIOS) {\n        final result = await iosValidator.validateReceipt(\n          purchase.transactionReceipt ?? '',\n        );\n        return result.isValid;\n      } else {\n        final result = await androidValidator.validateReceipt(purchase);\n        return result.isValid;\n      }\n    } catch (e) {\n      print('Client-side validation failed: $e');\n      return false;\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"integration-with-purchase-flow",children:"Integration with Purchase Flow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"class ValidatedPurchaseHandler {\n  final PurchaseValidationManager validator;\n  \n  ValidatedPurchaseHandler({required this.validator});\n  \n  Future<void> handlePurchase(PurchasedItem purchase) async {\n    try {\n      // Show validation in progress\n      _showValidationUI();\n      \n      // Validate the purchase\n      final isValid = await validator.validatePurchase(purchase);\n      \n      if (isValid) {\n        // Deliver content\n        await _deliverContent(purchase);\n        \n        // Finish transaction\n        await _finishTransaction(purchase);\n        \n        // Update UI\n        _showSuccessUI(purchase);\n        \n        // Track success\n        _trackValidationSuccess(purchase);\n        \n      } else {\n        // Handle invalid purchase\n        await _handleInvalidPurchase(purchase);\n      }\n      \n    } catch (e) {\n      await _handleValidationError(purchase, e);\n    } finally {\n      _hideValidationUI();\n    }\n  }\n  \n  Future<void> _handleInvalidPurchase(PurchasedItem purchase) async {\n    print('Invalid purchase detected: ${purchase.productId}');\n    \n    // Don't deliver content\n    // Don't finish transaction (keep it pending)\n    \n    // Log for investigation\n    _logInvalidPurchase(purchase);\n    \n    // Show error to user\n    _showInvalidPurchaseUI();\n  }\n  \n  Future<void> _handleValidationError(PurchasedItem purchase, dynamic error) async {\n    print('Validation error: $error');\n    \n    // Decide whether to deliver content based on error type\n    final shouldDeliver = _shouldDeliverOnValidationError(error);\n    \n    if (shouldDeliver) {\n      // Deliver content but log the issue\n      await _deliverContent(purchase);\n      await _finishTransaction(purchase);\n      _logValidationError(purchase, error);\n    } else {\n      // Keep transaction pending for manual review\n      _logValidationFailure(purchase, error);\n    }\n  }\n  \n  bool _shouldDeliverOnValidationError(dynamic error) {\n    // Conservative approach: only deliver on network errors\n    return error.toString().contains('network') ||\n           error.toString().contains('timeout');\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"receipt-storage-and-caching",children:"Receipt Storage and Caching"}),"\n",(0,t.jsx)(n.h3,{id:"receipt-cache-manager",children:"Receipt Cache Manager"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"class ReceiptCacheManager {\n  static const String _cacheKey = 'validated_receipts';\n  final SharedPreferences prefs;\n  \n  ReceiptCacheManager({required this.prefs});\n  \n  Future<void> cacheValidatedReceipt(\n    String transactionId,\n    Map<String, dynamic> receiptData,\n  ) async {\n    final cached = await _getCachedReceipts();\n    cached[transactionId] = {\n      'receiptData': receiptData,\n      'validatedAt': DateTime.now().millisecondsSinceEpoch,\n    };\n    \n    await prefs.setString(_cacheKey, json.encode(cached));\n  }\n  \n  Future<Map<String, dynamic>?> getCachedReceipt(String transactionId) async {\n    final cached = await _getCachedReceipts();\n    final receipt = cached[transactionId];\n    \n    if (receipt == null) return null;\n    \n    // Check if cache is still valid (24 hours)\n    final validatedAt = receipt['validatedAt'] as int;\n    final age = DateTime.now().millisecondsSinceEpoch - validatedAt;\n    \n    if (age > Duration(hours: 24).inMilliseconds) {\n      // Cache expired\n      cached.remove(transactionId);\n      await prefs.setString(_cacheKey, json.encode(cached));\n      return null;\n    }\n    \n    return receipt['receiptData'];\n  }\n  \n  Future<Map<String, dynamic>> _getCachedReceipts() async {\n    final cachedString = prefs.getString(_cacheKey);\n    if (cachedString == null) return {};\n    \n    try {\n      return json.decode(cachedString).cast<String, dynamic>();\n    } catch (e) {\n      return {};\n    }\n  }\n  \n  Future<void> clearCache() async {\n    await prefs.remove(_cacheKey);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing-receipt-validation",children:"Testing Receipt Validation"}),"\n",(0,t.jsx)(n.h3,{id:"test-receipt-generator",children:"Test Receipt Generator"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"class TestReceiptGenerator {\n  static Map<String, dynamic> generateTestIOSReceipt({\n    required String productId,\n    required String transactionId,\n    bool isValid = true,\n  }) {\n    return {\n      'receipt': {\n        'bundle_id': 'com.example.test',\n        'application_version': '1.0',\n        'environment': 'Sandbox',\n        'in_app': [\n          {\n            'product_id': productId,\n            'transaction_id': transactionId,\n            'purchase_date_ms': DateTime.now().millisecondsSinceEpoch.toString(),\n            'quantity': '1',\n          }\n        ],\n      },\n      'status': isValid ? 0 : 21002,\n    };\n  }\n  \n  static Map<String, dynamic> generateTestAndroidReceipt({\n    required String productId,\n    bool isValid = true,\n  }) {\n    return {\n      'purchaseState': isValid ? 0 : 1,\n      'consumptionState': 0,\n      'developerPayload': '',\n      'orderId': 'test_order_${DateTime.now().millisecondsSinceEpoch}',\n      'purchaseTimeMillis': DateTime.now().millisecondsSinceEpoch.toString(),\n      'purchaseToken': 'test_token_${DateTime.now().millisecondsSinceEpoch}',\n    };\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"validation-testing",children:"Validation Testing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"class ValidationTesting {\n  static Future<void> testValidationFlow() async {\n    final validator = PurchaseValidationManager(\n      serverValidator: MockServerValidator(),\n      iosValidator: MockIOSValidator(),\n      androidValidator: MockAndroidValidator(),\n    );\n    \n    // Test valid purchase\n    final validPurchase = _createTestPurchase(isValid: true);\n    final result1 = await validator.validatePurchase(validPurchase);\n    assert(result1 == true, 'Valid purchase should pass validation');\n    \n    // Test invalid purchase\n    final invalidPurchase = _createTestPurchase(isValid: false);\n    final result2 = await validator.validatePurchase(invalidPurchase);\n    assert(result2 == false, 'Invalid purchase should fail validation');\n    \n    print('All validation tests passed');\n  }\n  \n  static PurchasedItem _createTestPurchase({required bool isValid}) {\n    return PurchasedItem.fromJSON({\n      'productId': 'test_product',\n      'transactionId': 'test_transaction',\n      'transactionReceipt': isValid ? 'valid_receipt' : 'invalid_receipt',\n      'purchaseToken': isValid ? 'valid_token' : 'invalid_token',\n    });\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Always Use Server Validation"}),": Client-side validation can be bypassed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validate Before Content Delivery"}),": Never deliver without validation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handle Network Failures"}),": Implement retry logic and offline handling"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache Valid Receipts"}),": Avoid repeated validation of same receipt"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Log Validation Results"}),": Track validation patterns for debugging"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Secure Credentials"}),": Never hardcode secrets in client code"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test Edge Cases"}),": Test with expired, refunded, and tampered receipts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Monitor Validation Rates"}),": Track validation success/failure rates"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Shared Secrets"}),": Store iOS shared secrets securely on server only"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Access Tokens"}),": Use proper OAuth 2.0 flow for Google Play API"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Receipt Storage"}),": Store receipts securely for audit trail"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fraud Detection"}),": Implement additional fraud checks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rate Limiting"}),": Prevent validation API abuse"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environment Validation"}),": Ensure receipts match expected environment"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/guides/purchases",children:"Purchases Guide"})," - Purchase implementation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/guides/error-handling",children:"Error Handling"})," - Handling validation errors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/api/methods/validate-receipt",children:"API Reference"})," - Validation API methods"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var a=i(6540);const t={},r=a.createContext(t);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);