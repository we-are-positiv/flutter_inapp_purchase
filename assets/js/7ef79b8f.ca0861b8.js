"use strict";(self.webpackChunkflutter_inapp_purchase_docs=self.webpackChunkflutter_inapp_purchase_docs||[]).push([[7113],{3762:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"api/methods/finish-transaction","title":"finishTransaction","description":"Completes a transaction and removes it from the queue.","source":"@site/docs/api/methods/finish-transaction.md","sourceDirName":"api/methods","slug":"/api/methods/finish-transaction","permalink":"/docs/api/methods/finish-transaction","draft":false,"unlisted":false,"editUrl":"https://github.com/hyochan/flutter_inapp_purchase/tree/main/docs/docs/api/methods/finish-transaction.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"finishTransaction"}}');var s=i(4848),t=i(8453);const r={sidebar_position:6,title:"finishTransaction"},c="finishTransaction()",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Signatures",id:"signatures",level:2},{value:"expo-iap Compatible",id:"expo-iap-compatible",level:3},{value:"Legacy Method",id:"legacy-method",level:3},{value:"Parameters",id:"parameters",level:2},{value:"Platform Behavior",id:"platform-behavior",level:2},{value:"iOS",id:"ios",level:3},{value:"Android",id:"android",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Transaction Completion",id:"basic-transaction-completion",level:3},{value:"expo-iap Compatible Usage",id:"expo-iap-compatible-usage",level:3},{value:"Complete Purchase Flow",id:"complete-purchase-flow",level:3},{value:"Android-Specific Handling",id:"android-specific-handling",level:2},{value:"Pending Transactions",id:"pending-transactions",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Transaction States",id:"transaction-states",level:2},{value:"Related Methods",id:"related-methods",level:2},{value:"Important Notes",id:"important-notes",level:2}];function l(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"finishtransaction",children:"finishTransaction()"})}),"\n",(0,s.jsx)(e.p,{children:"Completes a transaction and removes it from the queue."}),"\n",(0,s.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(e.p,{children:["The ",(0,s.jsx)(e.code,{children:"finishTransaction()"})," method marks a transaction as complete, removing it from the pending transactions queue. This is crucial for proper transaction management on both iOS and Android platforms."]}),"\n",(0,s.jsx)(e.h2,{id:"signatures",children:"Signatures"}),"\n",(0,s.jsx)(e.h3,{id:"expo-iap-compatible",children:"expo-iap Compatible"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"Future<String?> finishTransaction(Purchase purchase, {bool isConsumable = false})\n"})}),"\n",(0,s.jsx)(e.h3,{id:"legacy-method",children:"Legacy Method"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"Future<String?> finishTransactionIOS(PurchasedItem purchasedItem, {bool isConsumable = false})\n"})}),"\n",(0,s.jsx)(e.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"purchase"})," / ",(0,s.jsx)(e.code,{children:"purchasedItem"})," - The purchase to finish"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"isConsumable"})," - Whether the product is consumable (affects Android behavior)"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"platform-behavior",children:"Platform Behavior"}),"\n",(0,s.jsx)(e.h3,{id:"ios",children:"iOS"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Removes the transaction from StoreKit's payment queue"}),"\n",(0,s.jsx)(e.li,{children:"Required for all purchases (consumable and non-consumable)"}),"\n",(0,s.jsx)(e.li,{children:"Must be called after content delivery"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"android",children:"Android"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"For consumables: Consumes the purchase, allowing repurchase"}),"\n",(0,s.jsx)(e.li,{children:"For non-consumables: Acknowledges the purchase"}),"\n",(0,s.jsx)(e.li,{children:"Must acknowledge within 3 days or purchase is refunded"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,s.jsx)(e.h3,{id:"basic-transaction-completion",children:"Basic Transaction Completion"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"// Listen for purchases and finish them\nFlutterInappPurchase.purchaseUpdated.listen((PurchasedItem? item) async {\n  if (item != null) {\n    // Verify and deliver content\n    await _verifyAndDeliver(item);\n\n    // Finish the transaction\n    await FlutterInappPurchase.instance.finishTransactionIOS(\n      item,\n      isConsumable: _isConsumable(item.productId),\n    );\n  }\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"expo-iap-compatible-usage",children:"expo-iap Compatible Usage"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"// Using the expo-iap compatible method\nFlutterInappPurchase.instance.purchaseUpdatedListener.listen((Purchase purchase) async {\n  // Process the purchase\n  await _processPurchase(purchase);\n\n  // Finish the transaction\n  await FlutterInappPurchase.instance.finishTransaction(\n    purchase,\n    isConsumable: true,\n  );\n});\n"})}),"\n",(0,s.jsx)(e.h3,{id:"complete-purchase-flow",children:"Complete Purchase Flow"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"class PurchaseHandler {\n  final _iap = FlutterInappPurchase.instance;\n  final _consumableIds = ['coins_100', 'coins_500', 'powerup_pack'];\n\n  void initialize() {\n    FlutterInappPurchase.purchaseUpdated.listen(_handlePurchase);\n  }\n\n  Future<void> _handlePurchase(PurchasedItem? item) async {\n    if (item == null) return;\n\n    try {\n      // Step 1: Verify the purchase\n      final isValid = await _verifyPurchase(item);\n      if (!isValid) {\n        print('Invalid purchase detected');\n        return;\n      }\n\n      // Step 2: Deliver the content\n      await _deliverContent(item.productId!);\n\n      // Step 3: Finish the transaction\n      final isConsumable = _consumableIds.contains(item.productId);\n      await _iap.finishTransactionIOS(item, isConsumable: isConsumable);\n\n      print('Transaction completed successfully');\n\n    } catch (e) {\n      print('Error processing purchase: $e');\n      // Don't finish transaction if processing failed\n      // This keeps it in the queue for retry\n    }\n  }\n\n  Future<bool> _verifyPurchase(PurchasedItem item) async {\n    // Implement your verification logic\n    // - Verify receipt with your backend\n    // - Check transaction ID uniqueness\n    // - Validate product ID\n    return true;\n  }\n\n  Future<void> _deliverContent(String productId) async {\n    // Deliver the purchased content\n    switch (productId) {\n      case 'coins_100':\n        await _addCoins(100);\n        break;\n      case 'coins_500':\n        await _addCoins(500);\n        break;\n      case 'premium':\n        await _unlockPremium();\n        break;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"android-specific-handling",children:"Android-Specific Handling"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"Future<void> handleAndroidPurchase(PurchasedItem item) async {\n  if (!Platform.isAndroid) return;\n\n  // Check acknowledgment status\n  if (item.isAcknowledgedAndroid == false) {\n    if (_isConsumable(item.productId)) {\n      // Consume the purchase\n      await _iap.consumePurchaseAndroid(item.purchaseToken!);\n    } else {\n      // Acknowledge non-consumable\n      await _iap.acknowledgePurchaseAndroid(\n        purchaseToken: item.purchaseToken!,\n      );\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"pending-transactions",children:"Pending Transactions"}),"\n",(0,s.jsx)(e.p,{children:"Handle pending transactions on app startup:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"class TransactionManager {\n  Future<void> processPendingTransactions() async {\n    try {\n      // Get pending transactions\n      final pending = await FlutterInappPurchase.instance.getPendingTransactionsIOS();\n\n      if (pending != null && pending.isNotEmpty) {\n        print('Found ${pending.length} pending transactions');\n\n        for (var transaction in pending) {\n          // Process each pending transaction\n          await _processPendingTransaction(transaction);\n        }\n      }\n    } catch (e) {\n      print('Error processing pending transactions: $e');\n    }\n  }\n\n  Future<void> _processPendingTransaction(PurchasedItem item) async {\n    // Verify the transaction\n    final isValid = await _verifyTransaction(item);\n\n    if (isValid) {\n      // Deliver content if not already delivered\n      if (!await _isContentDelivered(item.transactionId)) {\n        await _deliverContent(item.productId!);\n      }\n\n      // Finish the transaction\n      await FlutterInappPurchase.instance.finishTransaction(item);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Always Verify First"}),": Verify purchases before finishing transactions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Handle Failures"}),": Keep transactions pending if verification fails"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Idempotent Delivery"}),": Ensure content delivery is idempotent"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Process on Startup"}),": Check for pending transactions when app launches"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Track Delivery"}),": Maintain records of delivered content"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"Future<void> safeFinishTransaction(PurchasedItem item) async {\n  const maxRetries = 3;\n  var retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      await _iap.finishTransactionIOS(\n        item,\n        isConsumable: _isConsumable(item.productId),\n      );\n      print('Transaction finished successfully');\n      break;\n\n    } catch (e) {\n      retryCount++;\n      print('Failed to finish transaction (attempt $retryCount): $e');\n\n      if (retryCount >= maxRetries) {\n        // Log error but don't throw\n        // Transaction will remain pending\n        _logError('Failed to finish transaction after $maxRetries attempts', item);\n      } else {\n        // Wait before retry\n        await Future.delayed(Duration(seconds: retryCount));\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"transaction-states",children:"Transaction States"}),"\n",(0,s.jsx)(e.p,{children:"Monitor transaction states for proper handling:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-dart",children:"void handleTransactionState(PurchasedItem item) {\n  if (Platform.isIOS) {\n    switch (item.transactionStateIOS) {\n      case TransactionState.purchased:\n      case TransactionState.restored:\n        // Safe to finish\n        _finishTransaction(item);\n        break;\n      case TransactionState.failed:\n        // Don't finish failed transactions\n        print('Transaction failed');\n        break;\n      case TransactionState.purchasing:\n      case TransactionState.deferred:\n        // Wait for final state\n        print('Transaction pending');\n        break;\n    }\n  } else if (Platform.isAndroid) {\n    switch (item.purchaseStateAndroid) {\n      case PurchaseState.purchased:\n        // Safe to finish\n        _finishTransaction(item);\n        break;\n      case PurchaseState.pending:\n        // Don't finish pending transactions\n        print('Purchase pending');\n        break;\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"related-methods",children:"Related Methods"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/docs/api/methods/request-purchase",children:(0,s.jsx)(e.code,{children:"requestPurchase()"})})," - Initiates a purchase"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"/docs/api/methods/get-available-purchases",children:(0,s.jsx)(e.code,{children:"getAvailablePurchases()"})})," - Gets unfinished purchases"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"acknowledgePurchaseAndroid()"})," - Android-specific acknowledgment (see example above)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"consumePurchaseAndroid()"})," - Android-specific consumption (see example above)"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"iOS Requirements"}),": All transactions must be finished, even failed ones"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Android 3-Day Rule"}),": Acknowledge purchases within 3 days or they're refunded"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Consumables"}),": Must be consumed on Android to allow repurchase"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Network Failures"}),": Transactions remain pending if finish fails"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"App Termination"}),": Unfinished transactions persist across app sessions"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(l,{...n})}):l(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>r,x:()=>c});var a=i(6540);const s={},t=a.createContext(s);function r(n){const e=a.useContext(t);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),a.createElement(t.Provider,{value:e},n.children)}}}]);